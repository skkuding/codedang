# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Announcement {
  content: String!
  contest: Contest!
  contestId: Int!
  createTime: DateTime!
  id: ID!
  problem: Problem
  problemId: Int
  updateTime: DateTime!
}

type AnnouncementAvgAggregate {
  contestId: Float
  id: Float
  problemId: Float
}

type AnnouncementCountAggregate {
  _all: Int!
  content: Int!
  contestId: Int!
  createTime: Int!
  id: Int!
  problemId: Int!
  updateTime: Int!
}

input AnnouncementCreateManyContestInput {
  content: String!
  createTime: DateTime
  id: Int
  problemId: Int
  updateTime: DateTime
}

input AnnouncementCreateManyContestInputEnvelope {
  data: [AnnouncementCreateManyContestInput!]!
  skipDuplicates: Boolean
}

input AnnouncementCreateManyProblemInput {
  content: String!
  contestId: Int!
  createTime: DateTime
  id: Int
  updateTime: DateTime
}

input AnnouncementCreateManyProblemInputEnvelope {
  data: [AnnouncementCreateManyProblemInput!]!
  skipDuplicates: Boolean
}

input AnnouncementCreateNestedManyWithoutContestInput {
  connect: [AnnouncementWhereUniqueInput!]
  connectOrCreate: [AnnouncementCreateOrConnectWithoutContestInput!]
  create: [AnnouncementCreateWithoutContestInput!]
  createMany: AnnouncementCreateManyContestInputEnvelope
}

input AnnouncementCreateNestedManyWithoutProblemInput {
  connect: [AnnouncementWhereUniqueInput!]
  connectOrCreate: [AnnouncementCreateOrConnectWithoutProblemInput!]
  create: [AnnouncementCreateWithoutProblemInput!]
  createMany: AnnouncementCreateManyProblemInputEnvelope
}

input AnnouncementCreateOrConnectWithoutContestInput {
  create: AnnouncementCreateWithoutContestInput!
  where: AnnouncementWhereUniqueInput!
}

input AnnouncementCreateOrConnectWithoutProblemInput {
  create: AnnouncementCreateWithoutProblemInput!
  where: AnnouncementWhereUniqueInput!
}

input AnnouncementCreateWithoutContestInput {
  content: String!
  createTime: DateTime
  problem: ProblemCreateNestedOneWithoutAnnouncementInput
  updateTime: DateTime
}

input AnnouncementCreateWithoutProblemInput {
  content: String!
  contest: ContestCreateNestedOneWithoutAnnouncementInput!
  createTime: DateTime
  updateTime: DateTime
}

input AnnouncementInput {
  content: String!
  contestId: Int!
  problemId: Float
}

input AnnouncementListRelationFilter {
  every: AnnouncementWhereInput
  none: AnnouncementWhereInput
  some: AnnouncementWhereInput
}

type AnnouncementMaxAggregate {
  content: String
  contestId: Int
  createTime: DateTime
  id: Int
  problemId: Int
  updateTime: DateTime
}

type AnnouncementMinAggregate {
  content: String
  contestId: Int
  createTime: DateTime
  id: Int
  problemId: Int
  updateTime: DateTime
}

input AnnouncementScalarWhereInput {
  AND: [AnnouncementScalarWhereInput!]
  NOT: [AnnouncementScalarWhereInput!]
  OR: [AnnouncementScalarWhereInput!]
  content: StringFilter
  contestId: IntFilter
  createTime: DateTimeFilter
  id: IntFilter
  problemId: IntNullableFilter
  updateTime: DateTimeFilter
}

type AnnouncementSumAggregate {
  contestId: Int
  id: Int
  problemId: Int
}

input AnnouncementUpdateManyMutationInput {
  content: String
  createTime: DateTime
  updateTime: DateTime
}

input AnnouncementUpdateManyWithWhereWithoutContestInput {
  data: AnnouncementUpdateManyMutationInput!
  where: AnnouncementScalarWhereInput!
}

input AnnouncementUpdateManyWithWhereWithoutProblemInput {
  data: AnnouncementUpdateManyMutationInput!
  where: AnnouncementScalarWhereInput!
}

input AnnouncementUpdateManyWithoutContestNestedInput {
  connect: [AnnouncementWhereUniqueInput!]
  connectOrCreate: [AnnouncementCreateOrConnectWithoutContestInput!]
  create: [AnnouncementCreateWithoutContestInput!]
  createMany: AnnouncementCreateManyContestInputEnvelope
  delete: [AnnouncementWhereUniqueInput!]
  deleteMany: [AnnouncementScalarWhereInput!]
  disconnect: [AnnouncementWhereUniqueInput!]
  set: [AnnouncementWhereUniqueInput!]
  update: [AnnouncementUpdateWithWhereUniqueWithoutContestInput!]
  updateMany: [AnnouncementUpdateManyWithWhereWithoutContestInput!]
  upsert: [AnnouncementUpsertWithWhereUniqueWithoutContestInput!]
}

input AnnouncementUpdateManyWithoutProblemNestedInput {
  connect: [AnnouncementWhereUniqueInput!]
  connectOrCreate: [AnnouncementCreateOrConnectWithoutProblemInput!]
  create: [AnnouncementCreateWithoutProblemInput!]
  createMany: AnnouncementCreateManyProblemInputEnvelope
  delete: [AnnouncementWhereUniqueInput!]
  deleteMany: [AnnouncementScalarWhereInput!]
  disconnect: [AnnouncementWhereUniqueInput!]
  set: [AnnouncementWhereUniqueInput!]
  update: [AnnouncementUpdateWithWhereUniqueWithoutProblemInput!]
  updateMany: [AnnouncementUpdateManyWithWhereWithoutProblemInput!]
  upsert: [AnnouncementUpsertWithWhereUniqueWithoutProblemInput!]
}

input AnnouncementUpdateWithWhereUniqueWithoutContestInput {
  data: AnnouncementUpdateWithoutContestInput!
  where: AnnouncementWhereUniqueInput!
}

input AnnouncementUpdateWithWhereUniqueWithoutProblemInput {
  data: AnnouncementUpdateWithoutProblemInput!
  where: AnnouncementWhereUniqueInput!
}

input AnnouncementUpdateWithoutContestInput {
  content: String
  createTime: DateTime
  problem: ProblemUpdateOneWithoutAnnouncementNestedInput
  updateTime: DateTime
}

input AnnouncementUpdateWithoutProblemInput {
  content: String
  contest: ContestUpdateOneRequiredWithoutAnnouncementNestedInput
  createTime: DateTime
  updateTime: DateTime
}

input AnnouncementUpsertWithWhereUniqueWithoutContestInput {
  create: AnnouncementCreateWithoutContestInput!
  update: AnnouncementUpdateWithoutContestInput!
  where: AnnouncementWhereUniqueInput!
}

input AnnouncementUpsertWithWhereUniqueWithoutProblemInput {
  create: AnnouncementCreateWithoutProblemInput!
  update: AnnouncementUpdateWithoutProblemInput!
  where: AnnouncementWhereUniqueInput!
}

input AnnouncementWhereInput {
  AND: [AnnouncementWhereInput!]
  NOT: [AnnouncementWhereInput!]
  OR: [AnnouncementWhereInput!]
  content: StringFilter
  contest: ContestRelationFilter
  contestId: IntFilter
  createTime: DateTimeFilter
  id: IntFilter
  problem: ProblemNullableRelationFilter
  problemId: IntNullableFilter
  updateTime: DateTimeFilter
}

input AnnouncementWhereUniqueInput {
  AND: [AnnouncementWhereInput!]
  NOT: [AnnouncementWhereInput!]
  OR: [AnnouncementWhereInput!]
  content: StringFilter
  contest: ContestRelationFilter
  contestId: IntFilter
  createTime: DateTimeFilter
  id: Int
  problem: ProblemNullableRelationFilter
  problemId: IntNullableFilter
  updateTime: DateTimeFilter
}

input BigIntFilter {
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedBigIntFilter
  notIn: [String!]
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type CodeDraft {
  createTime: DateTime!
  problem: Problem!
  problemId: Int!

  """
  template code item structure
  {
  "lanaguage": Language,
  "code": {
  "id": number,
  "text": string,
  "locked": boolean
  }[]
  }
  """
  template: [JSON!]
  updateTime: DateTime!
  user: User!
  userId: Int!
}

type CodeDraftAvgAggregate {
  problemId: Float
  userId: Float
}

input CodeDraftCodeDraftIdCompoundUniqueInput {
  problemId: Int!
  userId: Int!
}

type CodeDraftCountAggregate {
  _all: Int!
  createTime: Int!
  problemId: Int!
  template: Int!
  updateTime: Int!
  userId: Int!
}

input CodeDraftCreateManyProblemInput {
  createTime: DateTime
  template: [JSON!]
  updateTime: DateTime
  userId: Int!
}

input CodeDraftCreateManyProblemInputEnvelope {
  data: [CodeDraftCreateManyProblemInput!]!
  skipDuplicates: Boolean
}

input CodeDraftCreateManyUserInput {
  createTime: DateTime
  problemId: Int!
  template: [JSON!]
  updateTime: DateTime
}

input CodeDraftCreateManyUserInputEnvelope {
  data: [CodeDraftCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input CodeDraftCreateNestedManyWithoutProblemInput {
  connect: [CodeDraftWhereUniqueInput!]
  connectOrCreate: [CodeDraftCreateOrConnectWithoutProblemInput!]
  create: [CodeDraftCreateWithoutProblemInput!]
  createMany: CodeDraftCreateManyProblemInputEnvelope
}

input CodeDraftCreateNestedManyWithoutUserInput {
  connect: [CodeDraftWhereUniqueInput!]
  connectOrCreate: [CodeDraftCreateOrConnectWithoutUserInput!]
  create: [CodeDraftCreateWithoutUserInput!]
  createMany: CodeDraftCreateManyUserInputEnvelope
}

input CodeDraftCreateOrConnectWithoutProblemInput {
  create: CodeDraftCreateWithoutProblemInput!
  where: CodeDraftWhereUniqueInput!
}

input CodeDraftCreateOrConnectWithoutUserInput {
  create: CodeDraftCreateWithoutUserInput!
  where: CodeDraftWhereUniqueInput!
}

input CodeDraftCreateWithoutProblemInput {
  createTime: DateTime
  template: [JSON!]
  updateTime: DateTime
  user: UserCreateNestedOneWithoutCodeDraftInput!
}

input CodeDraftCreateWithoutUserInput {
  createTime: DateTime
  problem: ProblemCreateNestedOneWithoutCodeDraftInput!
  template: [JSON!]
  updateTime: DateTime
}

input CodeDraftListRelationFilter {
  every: CodeDraftWhereInput
  none: CodeDraftWhereInput
  some: CodeDraftWhereInput
}

type CodeDraftMaxAggregate {
  createTime: DateTime
  problemId: Int
  updateTime: DateTime
  userId: Int
}

type CodeDraftMinAggregate {
  createTime: DateTime
  problemId: Int
  updateTime: DateTime
  userId: Int
}

input CodeDraftScalarWhereInput {
  AND: [CodeDraftScalarWhereInput!]
  NOT: [CodeDraftScalarWhereInput!]
  OR: [CodeDraftScalarWhereInput!]
  createTime: DateTimeFilter
  problemId: IntFilter
  template: JsonNullableListFilter
  updateTime: DateTimeFilter
  userId: IntFilter
}

type CodeDraftSumAggregate {
  problemId: Int
  userId: Int
}

input CodeDraftUpdateManyMutationInput {
  createTime: DateTime
  template: [JSON!]
  updateTime: DateTime
}

input CodeDraftUpdateManyWithWhereWithoutProblemInput {
  data: CodeDraftUpdateManyMutationInput!
  where: CodeDraftScalarWhereInput!
}

input CodeDraftUpdateManyWithWhereWithoutUserInput {
  data: CodeDraftUpdateManyMutationInput!
  where: CodeDraftScalarWhereInput!
}

input CodeDraftUpdateManyWithoutProblemNestedInput {
  connect: [CodeDraftWhereUniqueInput!]
  connectOrCreate: [CodeDraftCreateOrConnectWithoutProblemInput!]
  create: [CodeDraftCreateWithoutProblemInput!]
  createMany: CodeDraftCreateManyProblemInputEnvelope
  delete: [CodeDraftWhereUniqueInput!]
  deleteMany: [CodeDraftScalarWhereInput!]
  disconnect: [CodeDraftWhereUniqueInput!]
  set: [CodeDraftWhereUniqueInput!]
  update: [CodeDraftUpdateWithWhereUniqueWithoutProblemInput!]
  updateMany: [CodeDraftUpdateManyWithWhereWithoutProblemInput!]
  upsert: [CodeDraftUpsertWithWhereUniqueWithoutProblemInput!]
}

input CodeDraftUpdateManyWithoutUserNestedInput {
  connect: [CodeDraftWhereUniqueInput!]
  connectOrCreate: [CodeDraftCreateOrConnectWithoutUserInput!]
  create: [CodeDraftCreateWithoutUserInput!]
  createMany: CodeDraftCreateManyUserInputEnvelope
  delete: [CodeDraftWhereUniqueInput!]
  deleteMany: [CodeDraftScalarWhereInput!]
  disconnect: [CodeDraftWhereUniqueInput!]
  set: [CodeDraftWhereUniqueInput!]
  update: [CodeDraftUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [CodeDraftUpdateManyWithWhereWithoutUserInput!]
  upsert: [CodeDraftUpsertWithWhereUniqueWithoutUserInput!]
}

input CodeDraftUpdateWithWhereUniqueWithoutProblemInput {
  data: CodeDraftUpdateWithoutProblemInput!
  where: CodeDraftWhereUniqueInput!
}

input CodeDraftUpdateWithWhereUniqueWithoutUserInput {
  data: CodeDraftUpdateWithoutUserInput!
  where: CodeDraftWhereUniqueInput!
}

input CodeDraftUpdateWithoutProblemInput {
  createTime: DateTime
  template: [JSON!]
  updateTime: DateTime
  user: UserUpdateOneRequiredWithoutCodeDraftNestedInput
}

input CodeDraftUpdateWithoutUserInput {
  createTime: DateTime
  problem: ProblemUpdateOneRequiredWithoutCodeDraftNestedInput
  template: [JSON!]
  updateTime: DateTime
}

input CodeDraftUpsertWithWhereUniqueWithoutProblemInput {
  create: CodeDraftCreateWithoutProblemInput!
  update: CodeDraftUpdateWithoutProblemInput!
  where: CodeDraftWhereUniqueInput!
}

input CodeDraftUpsertWithWhereUniqueWithoutUserInput {
  create: CodeDraftCreateWithoutUserInput!
  update: CodeDraftUpdateWithoutUserInput!
  where: CodeDraftWhereUniqueInput!
}

input CodeDraftWhereInput {
  AND: [CodeDraftWhereInput!]
  NOT: [CodeDraftWhereInput!]
  OR: [CodeDraftWhereInput!]
  createTime: DateTimeFilter
  problem: ProblemRelationFilter
  problemId: IntFilter
  template: JsonNullableListFilter
  updateTime: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

input CodeDraftWhereUniqueInput {
  AND: [CodeDraftWhereInput!]
  NOT: [CodeDraftWhereInput!]
  OR: [CodeDraftWhereInput!]
  codeDraftId: CodeDraftCodeDraftIdCompoundUniqueInput
  createTime: DateTimeFilter
  problem: ProblemRelationFilter
  problemId: IntFilter
  template: JsonNullableListFilter
  updateTime: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

input Config {
  allowJoinFromSearch: Boolean!
  allowJoinWithURL: Boolean!
  requireApprovalBeforeJoin: Boolean!
  showOnList: Boolean!
}

type Contest {
  _count: ContestCount!
  announcement: [Announcement!]

  """
  config default value
  {
  "isVisible": true,
  "isRankVisible": true
  }
  """
  config: JSON!
  contestProblem: [ContestProblem!]
  contestRecord: [ContestRecord!]
  createTime: DateTime!
  createdBy: User
  createdById: Int
  description: String!
  endTime: DateTime!
  group: Group!
  groupId: Int!
  id: ID!
  startTime: DateTime!
  submission: [Submission!]
  title: String!
  updateTime: DateTime!
}

type ContestAvgAggregate {
  createdById: Float
  groupId: Float
  id: Float
}

input ContestConfig {
  isRankVisible: Boolean!
  isVisible: Boolean!
}

type ContestCount {
  announcement: Int!
  contestProblem: Int!
  contestRecord: Int!
  submission: Int!
}

type ContestCountAggregate {
  _all: Int!
  config: Int!
  createTime: Int!
  createdById: Int!
  description: Int!
  endTime: Int!
  groupId: Int!
  id: Int!
  startTime: Int!
  title: Int!
  updateTime: Int!
}

input ContestCreateManyCreatedByInput {
  config: JSON!
  createTime: DateTime
  description: String!
  endTime: DateTime!
  groupId: Int!
  id: Int
  startTime: DateTime!
  title: String!
  updateTime: DateTime
}

input ContestCreateManyCreatedByInputEnvelope {
  data: [ContestCreateManyCreatedByInput!]!
  skipDuplicates: Boolean
}

input ContestCreateManyGroupInput {
  config: JSON!
  createTime: DateTime
  createdById: Int
  description: String!
  endTime: DateTime!
  id: Int
  startTime: DateTime!
  title: String!
  updateTime: DateTime
}

input ContestCreateManyGroupInputEnvelope {
  data: [ContestCreateManyGroupInput!]!
  skipDuplicates: Boolean
}

input ContestCreateNestedManyWithoutCreatedByInput {
  connect: [ContestWhereUniqueInput!]
  connectOrCreate: [ContestCreateOrConnectWithoutCreatedByInput!]
  create: [ContestCreateWithoutCreatedByInput!]
  createMany: ContestCreateManyCreatedByInputEnvelope
}

input ContestCreateNestedManyWithoutGroupInput {
  connect: [ContestWhereUniqueInput!]
  connectOrCreate: [ContestCreateOrConnectWithoutGroupInput!]
  create: [ContestCreateWithoutGroupInput!]
  createMany: ContestCreateManyGroupInputEnvelope
}

input ContestCreateNestedOneWithoutAnnouncementInput {
  connect: ContestWhereUniqueInput
  connectOrCreate: ContestCreateOrConnectWithoutAnnouncementInput
  create: ContestCreateWithoutAnnouncementInput
}

input ContestCreateNestedOneWithoutContestProblemInput {
  connect: ContestWhereUniqueInput
  connectOrCreate: ContestCreateOrConnectWithoutContestProblemInput
  create: ContestCreateWithoutContestProblemInput
}

input ContestCreateNestedOneWithoutContestRecordInput {
  connect: ContestWhereUniqueInput
  connectOrCreate: ContestCreateOrConnectWithoutContestRecordInput
  create: ContestCreateWithoutContestRecordInput
}

input ContestCreateNestedOneWithoutSubmissionInput {
  connect: ContestWhereUniqueInput
  connectOrCreate: ContestCreateOrConnectWithoutSubmissionInput
  create: ContestCreateWithoutSubmissionInput
}

input ContestCreateOrConnectWithoutAnnouncementInput {
  create: ContestCreateWithoutAnnouncementInput!
  where: ContestWhereUniqueInput!
}

input ContestCreateOrConnectWithoutContestProblemInput {
  create: ContestCreateWithoutContestProblemInput!
  where: ContestWhereUniqueInput!
}

input ContestCreateOrConnectWithoutContestRecordInput {
  create: ContestCreateWithoutContestRecordInput!
  where: ContestWhereUniqueInput!
}

input ContestCreateOrConnectWithoutCreatedByInput {
  create: ContestCreateWithoutCreatedByInput!
  where: ContestWhereUniqueInput!
}

input ContestCreateOrConnectWithoutGroupInput {
  create: ContestCreateWithoutGroupInput!
  where: ContestWhereUniqueInput!
}

input ContestCreateOrConnectWithoutSubmissionInput {
  create: ContestCreateWithoutSubmissionInput!
  where: ContestWhereUniqueInput!
}

input ContestCreateWithoutAnnouncementInput {
  config: JSON!
  contestProblem: ContestProblemCreateNestedManyWithoutContestInput
  contestRecord: ContestRecordCreateNestedManyWithoutContestInput
  createTime: DateTime
  createdBy: UserCreateNestedOneWithoutContestInput
  description: String!
  endTime: DateTime!
  group: GroupCreateNestedOneWithoutContestInput!
  startTime: DateTime!
  submission: SubmissionCreateNestedManyWithoutContestInput
  title: String!
  updateTime: DateTime
}

input ContestCreateWithoutContestProblemInput {
  announcement: AnnouncementCreateNestedManyWithoutContestInput
  config: JSON!
  contestRecord: ContestRecordCreateNestedManyWithoutContestInput
  createTime: DateTime
  createdBy: UserCreateNestedOneWithoutContestInput
  description: String!
  endTime: DateTime!
  group: GroupCreateNestedOneWithoutContestInput!
  startTime: DateTime!
  submission: SubmissionCreateNestedManyWithoutContestInput
  title: String!
  updateTime: DateTime
}

input ContestCreateWithoutContestRecordInput {
  announcement: AnnouncementCreateNestedManyWithoutContestInput
  config: JSON!
  contestProblem: ContestProblemCreateNestedManyWithoutContestInput
  createTime: DateTime
  createdBy: UserCreateNestedOneWithoutContestInput
  description: String!
  endTime: DateTime!
  group: GroupCreateNestedOneWithoutContestInput!
  startTime: DateTime!
  submission: SubmissionCreateNestedManyWithoutContestInput
  title: String!
  updateTime: DateTime
}

input ContestCreateWithoutCreatedByInput {
  announcement: AnnouncementCreateNestedManyWithoutContestInput
  config: JSON!
  contestProblem: ContestProblemCreateNestedManyWithoutContestInput
  contestRecord: ContestRecordCreateNestedManyWithoutContestInput
  createTime: DateTime
  description: String!
  endTime: DateTime!
  group: GroupCreateNestedOneWithoutContestInput!
  startTime: DateTime!
  submission: SubmissionCreateNestedManyWithoutContestInput
  title: String!
  updateTime: DateTime
}

input ContestCreateWithoutGroupInput {
  announcement: AnnouncementCreateNestedManyWithoutContestInput
  config: JSON!
  contestProblem: ContestProblemCreateNestedManyWithoutContestInput
  contestRecord: ContestRecordCreateNestedManyWithoutContestInput
  createTime: DateTime
  createdBy: UserCreateNestedOneWithoutContestInput
  description: String!
  endTime: DateTime!
  startTime: DateTime!
  submission: SubmissionCreateNestedManyWithoutContestInput
  title: String!
  updateTime: DateTime
}

input ContestCreateWithoutSubmissionInput {
  announcement: AnnouncementCreateNestedManyWithoutContestInput
  config: JSON!
  contestProblem: ContestProblemCreateNestedManyWithoutContestInput
  contestRecord: ContestRecordCreateNestedManyWithoutContestInput
  createTime: DateTime
  createdBy: UserCreateNestedOneWithoutContestInput
  description: String!
  endTime: DateTime!
  group: GroupCreateNestedOneWithoutContestInput!
  startTime: DateTime!
  title: String!
  updateTime: DateTime
}

input ContestListRelationFilter {
  every: ContestWhereInput
  none: ContestWhereInput
  some: ContestWhereInput
}

type ContestMaxAggregate {
  createTime: DateTime
  createdById: Int
  description: String
  endTime: DateTime
  groupId: Int
  id: Int
  startTime: DateTime
  title: String
  updateTime: DateTime
}

type ContestMinAggregate {
  createTime: DateTime
  createdById: Int
  description: String
  endTime: DateTime
  groupId: Int
  id: Int
  startTime: DateTime
  title: String
  updateTime: DateTime
}

input ContestNullableRelationFilter {
  is: ContestWhereInput
  isNot: ContestWhereInput
}

type ContestProblem {
  contest: Contest!
  contestId: Int!
  createTime: DateTime!
  order: Int!
  problem: Problem!
  problemId: Int!
  score: Int!
  updateTime: DateTime!
}

type ContestProblemAvgAggregate {
  contestId: Float
  order: Float
  problemId: Float
  score: Float
}

input ContestProblemContestIdProblemIdCompoundUniqueInput {
  contestId: Int!
  problemId: Int!
}

type ContestProblemCountAggregate {
  _all: Int!
  contestId: Int!
  createTime: Int!
  order: Int!
  problemId: Int!
  score: Int!
  updateTime: Int!
}

input ContestProblemCreateManyContestInput {
  createTime: DateTime
  order: Int!
  problemId: Int!
  score: Int
  updateTime: DateTime
}

input ContestProblemCreateManyContestInputEnvelope {
  data: [ContestProblemCreateManyContestInput!]!
  skipDuplicates: Boolean
}

input ContestProblemCreateManyProblemInput {
  contestId: Int!
  createTime: DateTime
  order: Int!
  score: Int
  updateTime: DateTime
}

input ContestProblemCreateManyProblemInputEnvelope {
  data: [ContestProblemCreateManyProblemInput!]!
  skipDuplicates: Boolean
}

input ContestProblemCreateNestedManyWithoutContestInput {
  connect: [ContestProblemWhereUniqueInput!]
  connectOrCreate: [ContestProblemCreateOrConnectWithoutContestInput!]
  create: [ContestProblemCreateWithoutContestInput!]
  createMany: ContestProblemCreateManyContestInputEnvelope
}

input ContestProblemCreateNestedManyWithoutProblemInput {
  connect: [ContestProblemWhereUniqueInput!]
  connectOrCreate: [ContestProblemCreateOrConnectWithoutProblemInput!]
  create: [ContestProblemCreateWithoutProblemInput!]
  createMany: ContestProblemCreateManyProblemInputEnvelope
}

input ContestProblemCreateOrConnectWithoutContestInput {
  create: ContestProblemCreateWithoutContestInput!
  where: ContestProblemWhereUniqueInput!
}

input ContestProblemCreateOrConnectWithoutProblemInput {
  create: ContestProblemCreateWithoutProblemInput!
  where: ContestProblemWhereUniqueInput!
}

input ContestProblemCreateWithoutContestInput {
  createTime: DateTime
  order: Int!
  problem: ProblemCreateNestedOneWithoutContestProblemInput!
  score: Int
  updateTime: DateTime
}

input ContestProblemCreateWithoutProblemInput {
  contest: ContestCreateNestedOneWithoutContestProblemInput!
  createTime: DateTime
  order: Int!
  score: Int
  updateTime: DateTime
}

input ContestProblemListRelationFilter {
  every: ContestProblemWhereInput
  none: ContestProblemWhereInput
  some: ContestProblemWhereInput
}

type ContestProblemMaxAggregate {
  contestId: Int
  createTime: DateTime
  order: Int
  problemId: Int
  score: Int
  updateTime: DateTime
}

type ContestProblemMinAggregate {
  contestId: Int
  createTime: DateTime
  order: Int
  problemId: Int
  score: Int
  updateTime: DateTime
}

input ContestProblemScalarWhereInput {
  AND: [ContestProblemScalarWhereInput!]
  NOT: [ContestProblemScalarWhereInput!]
  OR: [ContestProblemScalarWhereInput!]
  contestId: IntFilter
  createTime: DateTimeFilter
  order: IntFilter
  problemId: IntFilter
  score: IntFilter
  updateTime: DateTimeFilter
}

type ContestProblemSumAggregate {
  contestId: Int
  order: Int
  problemId: Int
  score: Int
}

input ContestProblemUpdateManyMutationInput {
  createTime: DateTime
  order: Int
  score: Int
  updateTime: DateTime
}

input ContestProblemUpdateManyWithWhereWithoutContestInput {
  data: ContestProblemUpdateManyMutationInput!
  where: ContestProblemScalarWhereInput!
}

input ContestProblemUpdateManyWithWhereWithoutProblemInput {
  data: ContestProblemUpdateManyMutationInput!
  where: ContestProblemScalarWhereInput!
}

input ContestProblemUpdateManyWithoutContestNestedInput {
  connect: [ContestProblemWhereUniqueInput!]
  connectOrCreate: [ContestProblemCreateOrConnectWithoutContestInput!]
  create: [ContestProblemCreateWithoutContestInput!]
  createMany: ContestProblemCreateManyContestInputEnvelope
  delete: [ContestProblemWhereUniqueInput!]
  deleteMany: [ContestProblemScalarWhereInput!]
  disconnect: [ContestProblemWhereUniqueInput!]
  set: [ContestProblemWhereUniqueInput!]
  update: [ContestProblemUpdateWithWhereUniqueWithoutContestInput!]
  updateMany: [ContestProblemUpdateManyWithWhereWithoutContestInput!]
  upsert: [ContestProblemUpsertWithWhereUniqueWithoutContestInput!]
}

input ContestProblemUpdateManyWithoutProblemNestedInput {
  connect: [ContestProblemWhereUniqueInput!]
  connectOrCreate: [ContestProblemCreateOrConnectWithoutProblemInput!]
  create: [ContestProblemCreateWithoutProblemInput!]
  createMany: ContestProblemCreateManyProblemInputEnvelope
  delete: [ContestProblemWhereUniqueInput!]
  deleteMany: [ContestProblemScalarWhereInput!]
  disconnect: [ContestProblemWhereUniqueInput!]
  set: [ContestProblemWhereUniqueInput!]
  update: [ContestProblemUpdateWithWhereUniqueWithoutProblemInput!]
  updateMany: [ContestProblemUpdateManyWithWhereWithoutProblemInput!]
  upsert: [ContestProblemUpsertWithWhereUniqueWithoutProblemInput!]
}

input ContestProblemUpdateWithWhereUniqueWithoutContestInput {
  data: ContestProblemUpdateWithoutContestInput!
  where: ContestProblemWhereUniqueInput!
}

input ContestProblemUpdateWithWhereUniqueWithoutProblemInput {
  data: ContestProblemUpdateWithoutProblemInput!
  where: ContestProblemWhereUniqueInput!
}

input ContestProblemUpdateWithoutContestInput {
  createTime: DateTime
  order: Int
  problem: ProblemUpdateOneRequiredWithoutContestProblemNestedInput
  score: Int
  updateTime: DateTime
}

input ContestProblemUpdateWithoutProblemInput {
  contest: ContestUpdateOneRequiredWithoutContestProblemNestedInput
  createTime: DateTime
  order: Int
  score: Int
  updateTime: DateTime
}

input ContestProblemUpsertWithWhereUniqueWithoutContestInput {
  create: ContestProblemCreateWithoutContestInput!
  update: ContestProblemUpdateWithoutContestInput!
  where: ContestProblemWhereUniqueInput!
}

input ContestProblemUpsertWithWhereUniqueWithoutProblemInput {
  create: ContestProblemCreateWithoutProblemInput!
  update: ContestProblemUpdateWithoutProblemInput!
  where: ContestProblemWhereUniqueInput!
}

input ContestProblemWhereInput {
  AND: [ContestProblemWhereInput!]
  NOT: [ContestProblemWhereInput!]
  OR: [ContestProblemWhereInput!]
  contest: ContestRelationFilter
  contestId: IntFilter
  createTime: DateTimeFilter
  order: IntFilter
  problem: ProblemRelationFilter
  problemId: IntFilter
  score: IntFilter
  updateTime: DateTimeFilter
}

input ContestProblemWhereUniqueInput {
  AND: [ContestProblemWhereInput!]
  NOT: [ContestProblemWhereInput!]
  OR: [ContestProblemWhereInput!]
  contest: ContestRelationFilter
  contestId: IntFilter
  contestId_problemId: ContestProblemContestIdProblemIdCompoundUniqueInput
  createTime: DateTimeFilter
  order: IntFilter
  problem: ProblemRelationFilter
  problemId: IntFilter
  score: IntFilter
  updateTime: DateTimeFilter
}

type ContestRecord {
  acceptedProblemNum: Int!
  contest: Contest!
  contestId: Int!
  createTime: DateTime!
  id: ID!
  score: Int!
  totalPenalty: Int!
  updateTime: DateTime!
  user: User
  userId: Int
}

type ContestRecordAvgAggregate {
  acceptedProblemNum: Float
  contestId: Float
  id: Float
  score: Float
  totalPenalty: Float
  userId: Float
}

input ContestRecordContestIdUserIdCompoundUniqueInput {
  contestId: Int!
  userId: Int!
}

type ContestRecordCountAggregate {
  _all: Int!
  acceptedProblemNum: Int!
  contestId: Int!
  createTime: Int!
  id: Int!
  score: Int!
  totalPenalty: Int!
  updateTime: Int!
  userId: Int!
}

input ContestRecordCreateManyContestInput {
  acceptedProblemNum: Int
  createTime: DateTime
  id: Int
  score: Int
  totalPenalty: Int
  updateTime: DateTime
  userId: Int
}

input ContestRecordCreateManyContestInputEnvelope {
  data: [ContestRecordCreateManyContestInput!]!
  skipDuplicates: Boolean
}

input ContestRecordCreateManyUserInput {
  acceptedProblemNum: Int
  contestId: Int!
  createTime: DateTime
  id: Int
  score: Int
  totalPenalty: Int
  updateTime: DateTime
}

input ContestRecordCreateManyUserInputEnvelope {
  data: [ContestRecordCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input ContestRecordCreateNestedManyWithoutContestInput {
  connect: [ContestRecordWhereUniqueInput!]
  connectOrCreate: [ContestRecordCreateOrConnectWithoutContestInput!]
  create: [ContestRecordCreateWithoutContestInput!]
  createMany: ContestRecordCreateManyContestInputEnvelope
}

input ContestRecordCreateNestedManyWithoutUserInput {
  connect: [ContestRecordWhereUniqueInput!]
  connectOrCreate: [ContestRecordCreateOrConnectWithoutUserInput!]
  create: [ContestRecordCreateWithoutUserInput!]
  createMany: ContestRecordCreateManyUserInputEnvelope
}

input ContestRecordCreateOrConnectWithoutContestInput {
  create: ContestRecordCreateWithoutContestInput!
  where: ContestRecordWhereUniqueInput!
}

input ContestRecordCreateOrConnectWithoutUserInput {
  create: ContestRecordCreateWithoutUserInput!
  where: ContestRecordWhereUniqueInput!
}

input ContestRecordCreateWithoutContestInput {
  acceptedProblemNum: Int
  createTime: DateTime
  score: Int
  totalPenalty: Int
  updateTime: DateTime
  user: UserCreateNestedOneWithoutContestRecordInput
}

input ContestRecordCreateWithoutUserInput {
  acceptedProblemNum: Int
  contest: ContestCreateNestedOneWithoutContestRecordInput!
  createTime: DateTime
  score: Int
  totalPenalty: Int
  updateTime: DateTime
}

input ContestRecordListRelationFilter {
  every: ContestRecordWhereInput
  none: ContestRecordWhereInput
  some: ContestRecordWhereInput
}

type ContestRecordMaxAggregate {
  acceptedProblemNum: Int
  contestId: Int
  createTime: DateTime
  id: Int
  score: Int
  totalPenalty: Int
  updateTime: DateTime
  userId: Int
}

type ContestRecordMinAggregate {
  acceptedProblemNum: Int
  contestId: Int
  createTime: DateTime
  id: Int
  score: Int
  totalPenalty: Int
  updateTime: DateTime
  userId: Int
}

input ContestRecordScalarWhereInput {
  AND: [ContestRecordScalarWhereInput!]
  NOT: [ContestRecordScalarWhereInput!]
  OR: [ContestRecordScalarWhereInput!]
  acceptedProblemNum: IntFilter
  contestId: IntFilter
  createTime: DateTimeFilter
  id: IntFilter
  score: IntFilter
  totalPenalty: IntFilter
  updateTime: DateTimeFilter
  userId: IntNullableFilter
}

type ContestRecordSumAggregate {
  acceptedProblemNum: Int
  contestId: Int
  id: Int
  score: Int
  totalPenalty: Int
  userId: Int
}

input ContestRecordUpdateManyMutationInput {
  acceptedProblemNum: Int
  createTime: DateTime
  score: Int
  totalPenalty: Int
  updateTime: DateTime
}

input ContestRecordUpdateManyWithWhereWithoutContestInput {
  data: ContestRecordUpdateManyMutationInput!
  where: ContestRecordScalarWhereInput!
}

input ContestRecordUpdateManyWithWhereWithoutUserInput {
  data: ContestRecordUpdateManyMutationInput!
  where: ContestRecordScalarWhereInput!
}

input ContestRecordUpdateManyWithoutContestNestedInput {
  connect: [ContestRecordWhereUniqueInput!]
  connectOrCreate: [ContestRecordCreateOrConnectWithoutContestInput!]
  create: [ContestRecordCreateWithoutContestInput!]
  createMany: ContestRecordCreateManyContestInputEnvelope
  delete: [ContestRecordWhereUniqueInput!]
  deleteMany: [ContestRecordScalarWhereInput!]
  disconnect: [ContestRecordWhereUniqueInput!]
  set: [ContestRecordWhereUniqueInput!]
  update: [ContestRecordUpdateWithWhereUniqueWithoutContestInput!]
  updateMany: [ContestRecordUpdateManyWithWhereWithoutContestInput!]
  upsert: [ContestRecordUpsertWithWhereUniqueWithoutContestInput!]
}

input ContestRecordUpdateManyWithoutUserNestedInput {
  connect: [ContestRecordWhereUniqueInput!]
  connectOrCreate: [ContestRecordCreateOrConnectWithoutUserInput!]
  create: [ContestRecordCreateWithoutUserInput!]
  createMany: ContestRecordCreateManyUserInputEnvelope
  delete: [ContestRecordWhereUniqueInput!]
  deleteMany: [ContestRecordScalarWhereInput!]
  disconnect: [ContestRecordWhereUniqueInput!]
  set: [ContestRecordWhereUniqueInput!]
  update: [ContestRecordUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ContestRecordUpdateManyWithWhereWithoutUserInput!]
  upsert: [ContestRecordUpsertWithWhereUniqueWithoutUserInput!]
}

input ContestRecordUpdateWithWhereUniqueWithoutContestInput {
  data: ContestRecordUpdateWithoutContestInput!
  where: ContestRecordWhereUniqueInput!
}

input ContestRecordUpdateWithWhereUniqueWithoutUserInput {
  data: ContestRecordUpdateWithoutUserInput!
  where: ContestRecordWhereUniqueInput!
}

input ContestRecordUpdateWithoutContestInput {
  acceptedProblemNum: Int
  createTime: DateTime
  score: Int
  totalPenalty: Int
  updateTime: DateTime
  user: UserUpdateOneWithoutContestRecordNestedInput
}

input ContestRecordUpdateWithoutUserInput {
  acceptedProblemNum: Int
  contest: ContestUpdateOneRequiredWithoutContestRecordNestedInput
  createTime: DateTime
  score: Int
  totalPenalty: Int
  updateTime: DateTime
}

input ContestRecordUpsertWithWhereUniqueWithoutContestInput {
  create: ContestRecordCreateWithoutContestInput!
  update: ContestRecordUpdateWithoutContestInput!
  where: ContestRecordWhereUniqueInput!
}

input ContestRecordUpsertWithWhereUniqueWithoutUserInput {
  create: ContestRecordCreateWithoutUserInput!
  update: ContestRecordUpdateWithoutUserInput!
  where: ContestRecordWhereUniqueInput!
}

input ContestRecordWhereInput {
  AND: [ContestRecordWhereInput!]
  NOT: [ContestRecordWhereInput!]
  OR: [ContestRecordWhereInput!]
  acceptedProblemNum: IntFilter
  contest: ContestRelationFilter
  contestId: IntFilter
  createTime: DateTimeFilter
  id: IntFilter
  score: IntFilter
  totalPenalty: IntFilter
  updateTime: DateTimeFilter
  user: UserNullableRelationFilter
  userId: IntNullableFilter
}

input ContestRecordWhereUniqueInput {
  AND: [ContestRecordWhereInput!]
  NOT: [ContestRecordWhereInput!]
  OR: [ContestRecordWhereInput!]
  acceptedProblemNum: IntFilter
  contest: ContestRelationFilter
  contestId: IntFilter
  contestId_userId: ContestRecordContestIdUserIdCompoundUniqueInput
  createTime: DateTimeFilter
  id: Int
  score: IntFilter
  totalPenalty: IntFilter
  updateTime: DateTimeFilter
  user: UserNullableRelationFilter
  userId: IntNullableFilter
}

input ContestRelationFilter {
  is: ContestWhereInput
  isNot: ContestWhereInput
}

input ContestScalarWhereInput {
  AND: [ContestScalarWhereInput!]
  NOT: [ContestScalarWhereInput!]
  OR: [ContestScalarWhereInput!]
  config: JsonFilter
  createTime: DateTimeFilter
  createdById: IntNullableFilter
  description: StringFilter
  endTime: DateTimeFilter
  groupId: IntFilter
  id: IntFilter
  startTime: DateTimeFilter
  title: StringFilter
  updateTime: DateTimeFilter
}

type ContestSumAggregate {
  createdById: Int
  groupId: Int
  id: Int
}

input ContestUpdateManyMutationInput {
  config: JSON
  createTime: DateTime
  description: String
  endTime: DateTime
  startTime: DateTime
  title: String
  updateTime: DateTime
}

input ContestUpdateManyWithWhereWithoutCreatedByInput {
  data: ContestUpdateManyMutationInput!
  where: ContestScalarWhereInput!
}

input ContestUpdateManyWithWhereWithoutGroupInput {
  data: ContestUpdateManyMutationInput!
  where: ContestScalarWhereInput!
}

input ContestUpdateManyWithoutCreatedByNestedInput {
  connect: [ContestWhereUniqueInput!]
  connectOrCreate: [ContestCreateOrConnectWithoutCreatedByInput!]
  create: [ContestCreateWithoutCreatedByInput!]
  createMany: ContestCreateManyCreatedByInputEnvelope
  delete: [ContestWhereUniqueInput!]
  deleteMany: [ContestScalarWhereInput!]
  disconnect: [ContestWhereUniqueInput!]
  set: [ContestWhereUniqueInput!]
  update: [ContestUpdateWithWhereUniqueWithoutCreatedByInput!]
  updateMany: [ContestUpdateManyWithWhereWithoutCreatedByInput!]
  upsert: [ContestUpsertWithWhereUniqueWithoutCreatedByInput!]
}

input ContestUpdateManyWithoutGroupNestedInput {
  connect: [ContestWhereUniqueInput!]
  connectOrCreate: [ContestCreateOrConnectWithoutGroupInput!]
  create: [ContestCreateWithoutGroupInput!]
  createMany: ContestCreateManyGroupInputEnvelope
  delete: [ContestWhereUniqueInput!]
  deleteMany: [ContestScalarWhereInput!]
  disconnect: [ContestWhereUniqueInput!]
  set: [ContestWhereUniqueInput!]
  update: [ContestUpdateWithWhereUniqueWithoutGroupInput!]
  updateMany: [ContestUpdateManyWithWhereWithoutGroupInput!]
  upsert: [ContestUpsertWithWhereUniqueWithoutGroupInput!]
}

input ContestUpdateOneRequiredWithoutAnnouncementNestedInput {
  connect: ContestWhereUniqueInput
  connectOrCreate: ContestCreateOrConnectWithoutAnnouncementInput
  create: ContestCreateWithoutAnnouncementInput
  update: ContestUpdateToOneWithWhereWithoutAnnouncementInput
  upsert: ContestUpsertWithoutAnnouncementInput
}

input ContestUpdateOneRequiredWithoutContestProblemNestedInput {
  connect: ContestWhereUniqueInput
  connectOrCreate: ContestCreateOrConnectWithoutContestProblemInput
  create: ContestCreateWithoutContestProblemInput
  update: ContestUpdateToOneWithWhereWithoutContestProblemInput
  upsert: ContestUpsertWithoutContestProblemInput
}

input ContestUpdateOneRequiredWithoutContestRecordNestedInput {
  connect: ContestWhereUniqueInput
  connectOrCreate: ContestCreateOrConnectWithoutContestRecordInput
  create: ContestCreateWithoutContestRecordInput
  update: ContestUpdateToOneWithWhereWithoutContestRecordInput
  upsert: ContestUpsertWithoutContestRecordInput
}

input ContestUpdateOneWithoutSubmissionNestedInput {
  connect: ContestWhereUniqueInput
  connectOrCreate: ContestCreateOrConnectWithoutSubmissionInput
  create: ContestCreateWithoutSubmissionInput
  delete: ContestWhereInput
  disconnect: ContestWhereInput
  update: ContestUpdateToOneWithWhereWithoutSubmissionInput
  upsert: ContestUpsertWithoutSubmissionInput
}

input ContestUpdateToOneWithWhereWithoutAnnouncementInput {
  data: ContestUpdateWithoutAnnouncementInput!
  where: ContestWhereInput
}

input ContestUpdateToOneWithWhereWithoutContestProblemInput {
  data: ContestUpdateWithoutContestProblemInput!
  where: ContestWhereInput
}

input ContestUpdateToOneWithWhereWithoutContestRecordInput {
  data: ContestUpdateWithoutContestRecordInput!
  where: ContestWhereInput
}

input ContestUpdateToOneWithWhereWithoutSubmissionInput {
  data: ContestUpdateWithoutSubmissionInput!
  where: ContestWhereInput
}

input ContestUpdateWithWhereUniqueWithoutCreatedByInput {
  data: ContestUpdateWithoutCreatedByInput!
  where: ContestWhereUniqueInput!
}

input ContestUpdateWithWhereUniqueWithoutGroupInput {
  data: ContestUpdateWithoutGroupInput!
  where: ContestWhereUniqueInput!
}

input ContestUpdateWithoutAnnouncementInput {
  config: JSON
  contestProblem: ContestProblemUpdateManyWithoutContestNestedInput
  contestRecord: ContestRecordUpdateManyWithoutContestNestedInput
  createTime: DateTime
  createdBy: UserUpdateOneWithoutContestNestedInput
  description: String
  endTime: DateTime
  group: GroupUpdateOneRequiredWithoutContestNestedInput
  startTime: DateTime
  submission: SubmissionUpdateManyWithoutContestNestedInput
  title: String
  updateTime: DateTime
}

input ContestUpdateWithoutContestProblemInput {
  announcement: AnnouncementUpdateManyWithoutContestNestedInput
  config: JSON
  contestRecord: ContestRecordUpdateManyWithoutContestNestedInput
  createTime: DateTime
  createdBy: UserUpdateOneWithoutContestNestedInput
  description: String
  endTime: DateTime
  group: GroupUpdateOneRequiredWithoutContestNestedInput
  startTime: DateTime
  submission: SubmissionUpdateManyWithoutContestNestedInput
  title: String
  updateTime: DateTime
}

input ContestUpdateWithoutContestRecordInput {
  announcement: AnnouncementUpdateManyWithoutContestNestedInput
  config: JSON
  contestProblem: ContestProblemUpdateManyWithoutContestNestedInput
  createTime: DateTime
  createdBy: UserUpdateOneWithoutContestNestedInput
  description: String
  endTime: DateTime
  group: GroupUpdateOneRequiredWithoutContestNestedInput
  startTime: DateTime
  submission: SubmissionUpdateManyWithoutContestNestedInput
  title: String
  updateTime: DateTime
}

input ContestUpdateWithoutCreatedByInput {
  announcement: AnnouncementUpdateManyWithoutContestNestedInput
  config: JSON
  contestProblem: ContestProblemUpdateManyWithoutContestNestedInput
  contestRecord: ContestRecordUpdateManyWithoutContestNestedInput
  createTime: DateTime
  description: String
  endTime: DateTime
  group: GroupUpdateOneRequiredWithoutContestNestedInput
  startTime: DateTime
  submission: SubmissionUpdateManyWithoutContestNestedInput
  title: String
  updateTime: DateTime
}

input ContestUpdateWithoutGroupInput {
  announcement: AnnouncementUpdateManyWithoutContestNestedInput
  config: JSON
  contestProblem: ContestProblemUpdateManyWithoutContestNestedInput
  contestRecord: ContestRecordUpdateManyWithoutContestNestedInput
  createTime: DateTime
  createdBy: UserUpdateOneWithoutContestNestedInput
  description: String
  endTime: DateTime
  startTime: DateTime
  submission: SubmissionUpdateManyWithoutContestNestedInput
  title: String
  updateTime: DateTime
}

input ContestUpdateWithoutSubmissionInput {
  announcement: AnnouncementUpdateManyWithoutContestNestedInput
  config: JSON
  contestProblem: ContestProblemUpdateManyWithoutContestNestedInput
  contestRecord: ContestRecordUpdateManyWithoutContestNestedInput
  createTime: DateTime
  createdBy: UserUpdateOneWithoutContestNestedInput
  description: String
  endTime: DateTime
  group: GroupUpdateOneRequiredWithoutContestNestedInput
  startTime: DateTime
  title: String
  updateTime: DateTime
}

input ContestUpsertWithWhereUniqueWithoutCreatedByInput {
  create: ContestCreateWithoutCreatedByInput!
  update: ContestUpdateWithoutCreatedByInput!
  where: ContestWhereUniqueInput!
}

input ContestUpsertWithWhereUniqueWithoutGroupInput {
  create: ContestCreateWithoutGroupInput!
  update: ContestUpdateWithoutGroupInput!
  where: ContestWhereUniqueInput!
}

input ContestUpsertWithoutAnnouncementInput {
  create: ContestCreateWithoutAnnouncementInput!
  update: ContestUpdateWithoutAnnouncementInput!
  where: ContestWhereInput
}

input ContestUpsertWithoutContestProblemInput {
  create: ContestCreateWithoutContestProblemInput!
  update: ContestUpdateWithoutContestProblemInput!
  where: ContestWhereInput
}

input ContestUpsertWithoutContestRecordInput {
  create: ContestCreateWithoutContestRecordInput!
  update: ContestUpdateWithoutContestRecordInput!
  where: ContestWhereInput
}

input ContestUpsertWithoutSubmissionInput {
  create: ContestCreateWithoutSubmissionInput!
  update: ContestUpdateWithoutSubmissionInput!
  where: ContestWhereInput
}

input ContestWhereInput {
  AND: [ContestWhereInput!]
  NOT: [ContestWhereInput!]
  OR: [ContestWhereInput!]
  announcement: AnnouncementListRelationFilter
  config: JsonFilter
  contestProblem: ContestProblemListRelationFilter
  contestRecord: ContestRecordListRelationFilter
  createTime: DateTimeFilter
  createdBy: UserNullableRelationFilter
  createdById: IntNullableFilter
  description: StringFilter
  endTime: DateTimeFilter
  group: GroupRelationFilter
  groupId: IntFilter
  id: IntFilter
  startTime: DateTimeFilter
  submission: SubmissionListRelationFilter
  title: StringFilter
  updateTime: DateTimeFilter
}

input ContestWhereUniqueInput {
  AND: [ContestWhereInput!]
  NOT: [ContestWhereInput!]
  OR: [ContestWhereInput!]
  announcement: AnnouncementListRelationFilter
  config: JsonFilter
  contestProblem: ContestProblemListRelationFilter
  contestRecord: ContestRecordListRelationFilter
  createTime: DateTimeFilter
  createdBy: UserNullableRelationFilter
  createdById: IntNullableFilter
  description: StringFilter
  endTime: DateTimeFilter
  group: GroupRelationFilter
  groupId: IntFilter
  id: Int
  startTime: DateTimeFilter
  submission: SubmissionListRelationFilter
  title: StringFilter
  updateTime: DateTimeFilter
}

"""contestWithParticipants"""
type ContestWithParticipants {
  _count: ContestCount!
  announcement: [Announcement!]

  """
  config default value
  {
  "isVisible": true,
  "isRankVisible": true
  }
  """
  config: JSON!
  contestProblem: [ContestProblem!]
  contestRecord: [ContestRecord!]
  createTime: DateTime!
  createdBy: User
  createdById: Int
  description: String!
  endTime: DateTime!
  group: Group!
  groupId: Int!
  id: ID!
  participants: Int!
  startTime: DateTime!
  submission: [Submission!]
  title: String!
  updateTime: DateTime!
}

input CreateContestInput {
  config: ContestConfig!
  description: String!
  endTime: DateTime!
  startTime: DateTime!
  title: String!
}

input CreateGroupInput {
  config: Config!
  contest: ContestCreateNestedManyWithoutGroupInput
  createTime: DateTime
  description: String!
  groupName: String!
  notice: NoticeCreateNestedManyWithoutGroupInput
  problem: ProblemCreateNestedManyWithoutGroupInput
  updateTime: DateTime
  userGroup: UserGroupCreateNestedManyWithoutGroupInput
  workbook: WorkbookCreateNestedManyWithoutGroupInput
}

input CreateNoticeInput {
  content: String!
  isFixed: Boolean
  isVisible: Boolean
  title: String!
}

input CreateProblemInput {
  description: String!
  difficulty: Level!
  hint: String!
  inputDescription: String!
  isVisible: Boolean! = true
  languages: [Language!]!
  memoryLimit: Int!
  outputDescription: String!
  samples: [Sample!]!
  source: String!
  tagIds: [Int!]!
  template: [Template!]!
  testcases: [Testcase!]!
  timeLimit: Int!
  title: String!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

type DeletedUserGroup {
  count: Int!
}

input EnumLanguageFilter {
  equals: Language
  in: [Language!]
  not: NestedEnumLanguageFilter
  notIn: [Language!]
}

input EnumLanguageNullableListFilter {
  equals: [Language!]
  has: Language
  hasEvery: [Language!]
  hasSome: [Language!]
  isEmpty: Boolean
}

input EnumLevelFilter {
  equals: Level
  in: [Level!]
  not: NestedEnumLevelFilter
  notIn: [Level!]
}

input EnumProviderFilter {
  equals: Provider
  in: [Provider!]
  not: NestedEnumProviderFilter
  notIn: [Provider!]
}

input EnumResultStatusFilter {
  equals: ResultStatus
  in: [ResultStatus!]
  not: NestedEnumResultStatusFilter
  notIn: [ResultStatus!]
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

type ExampleIO {
  createTime: DateTime!
  id: ID!
  input: String!
  output: String!
  problem: Problem!
  problemId: Int!
  updateTime: DateTime!
}

type ExampleIOAvgAggregate {
  id: Float
  problemId: Float
}

type ExampleIOCountAggregate {
  _all: Int!
  createTime: Int!
  id: Int!
  input: Int!
  output: Int!
  problemId: Int!
  updateTime: Int!
}

input ExampleIOCreateManyProblemInput {
  createTime: DateTime
  id: Int
  input: String!
  output: String!
  updateTime: DateTime
}

input ExampleIOCreateManyProblemInputEnvelope {
  data: [ExampleIOCreateManyProblemInput!]!
  skipDuplicates: Boolean
}

input ExampleIOCreateNestedManyWithoutProblemInput {
  connect: [ExampleIOWhereUniqueInput!]
  connectOrCreate: [ExampleIOCreateOrConnectWithoutProblemInput!]
  create: [ExampleIOCreateWithoutProblemInput!]
  createMany: ExampleIOCreateManyProblemInputEnvelope
}

input ExampleIOCreateOrConnectWithoutProblemInput {
  create: ExampleIOCreateWithoutProblemInput!
  where: ExampleIOWhereUniqueInput!
}

input ExampleIOCreateWithoutProblemInput {
  createTime: DateTime
  input: String!
  output: String!
  updateTime: DateTime
}

input ExampleIOListRelationFilter {
  every: ExampleIOWhereInput
  none: ExampleIOWhereInput
  some: ExampleIOWhereInput
}

type ExampleIOMaxAggregate {
  createTime: DateTime
  id: Int
  input: String
  output: String
  problemId: Int
  updateTime: DateTime
}

type ExampleIOMinAggregate {
  createTime: DateTime
  id: Int
  input: String
  output: String
  problemId: Int
  updateTime: DateTime
}

input ExampleIOScalarWhereInput {
  AND: [ExampleIOScalarWhereInput!]
  NOT: [ExampleIOScalarWhereInput!]
  OR: [ExampleIOScalarWhereInput!]
  createTime: DateTimeFilter
  id: IntFilter
  input: StringFilter
  output: StringFilter
  problemId: IntFilter
  updateTime: DateTimeFilter
}

type ExampleIOSumAggregate {
  id: Int
  problemId: Int
}

input ExampleIOUpdateManyMutationInput {
  createTime: DateTime
  input: String
  output: String
  updateTime: DateTime
}

input ExampleIOUpdateManyWithWhereWithoutProblemInput {
  data: ExampleIOUpdateManyMutationInput!
  where: ExampleIOScalarWhereInput!
}

input ExampleIOUpdateManyWithoutProblemNestedInput {
  connect: [ExampleIOWhereUniqueInput!]
  connectOrCreate: [ExampleIOCreateOrConnectWithoutProblemInput!]
  create: [ExampleIOCreateWithoutProblemInput!]
  createMany: ExampleIOCreateManyProblemInputEnvelope
  delete: [ExampleIOWhereUniqueInput!]
  deleteMany: [ExampleIOScalarWhereInput!]
  disconnect: [ExampleIOWhereUniqueInput!]
  set: [ExampleIOWhereUniqueInput!]
  update: [ExampleIOUpdateWithWhereUniqueWithoutProblemInput!]
  updateMany: [ExampleIOUpdateManyWithWhereWithoutProblemInput!]
  upsert: [ExampleIOUpsertWithWhereUniqueWithoutProblemInput!]
}

input ExampleIOUpdateWithWhereUniqueWithoutProblemInput {
  data: ExampleIOUpdateWithoutProblemInput!
  where: ExampleIOWhereUniqueInput!
}

input ExampleIOUpdateWithoutProblemInput {
  createTime: DateTime
  input: String
  output: String
  updateTime: DateTime
}

input ExampleIOUpsertWithWhereUniqueWithoutProblemInput {
  create: ExampleIOCreateWithoutProblemInput!
  update: ExampleIOUpdateWithoutProblemInput!
  where: ExampleIOWhereUniqueInput!
}

input ExampleIOWhereInput {
  AND: [ExampleIOWhereInput!]
  NOT: [ExampleIOWhereInput!]
  OR: [ExampleIOWhereInput!]
  createTime: DateTimeFilter
  id: IntFilter
  input: StringFilter
  output: StringFilter
  problem: ProblemRelationFilter
  problemId: IntFilter
  updateTime: DateTimeFilter
}

input ExampleIOWhereUniqueInput {
  AND: [ExampleIOWhereInput!]
  NOT: [ExampleIOWhereInput!]
  OR: [ExampleIOWhereInput!]
  createTime: DateTimeFilter
  id: Int
  input: StringFilter
  output: StringFilter
  problem: ProblemRelationFilter
  problemId: IntFilter
  updateTime: DateTimeFilter
}

input FilterProblemsInput {
  difficulty: [Level!]
  languages: [Language!]
}

type FindGroup {
  _count: GroupCount!

  """
  config default value
  {
  "showOnList": true,          // show on 'all groups' list
  "allowJoinFromSearch": true, // can join from 'all groups' list. set to false if `showOnList` is false
  "allowJoinWithURL": false,
  "requireApprovalBeforeJoin": true
  }
  """
  config: JSON!
  contest: [Contest!]
  createTime: DateTime!
  description: String!
  groupName: String!
  id: ID!
  memberNum: Int!
  notice: [Notice!]
  problem: [Problem!]
  updateTime: DateTime!
  userGroup: [UserGroup!]
  workbook: [Workbook!]
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

type Group {
  _count: GroupCount!

  """
  config default value
  {
  "showOnList": true,          // show on 'all groups' list
  "allowJoinFromSearch": true, // can join from 'all groups' list. set to false if `showOnList` is false
  "allowJoinWithURL": false,
  "requireApprovalBeforeJoin": true
  }
  """
  config: JSON!
  contest: [Contest!]
  createTime: DateTime!
  description: String!
  groupName: String!
  id: ID!
  notice: [Notice!]
  problem: [Problem!]
  updateTime: DateTime!
  userGroup: [UserGroup!]
  workbook: [Workbook!]
}

type GroupAvgAggregate {
  id: Float
}

type GroupCount {
  contest: Int!
  notice: Int!
  problem: Int!
  userGroup: Int!
  workbook: Int!
}

type GroupCountAggregate {
  _all: Int!
  config: Int!
  createTime: Int!
  description: Int!
  groupName: Int!
  id: Int!
  updateTime: Int!
}

input GroupCreateNestedOneWithoutContestInput {
  connect: GroupWhereUniqueInput
  connectOrCreate: GroupCreateOrConnectWithoutContestInput
  create: GroupCreateWithoutContestInput
}

input GroupCreateNestedOneWithoutNoticeInput {
  connect: GroupWhereUniqueInput
  connectOrCreate: GroupCreateOrConnectWithoutNoticeInput
  create: GroupCreateWithoutNoticeInput
}

input GroupCreateNestedOneWithoutProblemInput {
  connect: GroupWhereUniqueInput
  connectOrCreate: GroupCreateOrConnectWithoutProblemInput
  create: GroupCreateWithoutProblemInput
}

input GroupCreateNestedOneWithoutUserGroupInput {
  connect: GroupWhereUniqueInput
  connectOrCreate: GroupCreateOrConnectWithoutUserGroupInput
  create: GroupCreateWithoutUserGroupInput
}

input GroupCreateNestedOneWithoutWorkbookInput {
  connect: GroupWhereUniqueInput
  connectOrCreate: GroupCreateOrConnectWithoutWorkbookInput
  create: GroupCreateWithoutWorkbookInput
}

input GroupCreateOrConnectWithoutContestInput {
  create: GroupCreateWithoutContestInput!
  where: GroupWhereUniqueInput!
}

input GroupCreateOrConnectWithoutNoticeInput {
  create: GroupCreateWithoutNoticeInput!
  where: GroupWhereUniqueInput!
}

input GroupCreateOrConnectWithoutProblemInput {
  create: GroupCreateWithoutProblemInput!
  where: GroupWhereUniqueInput!
}

input GroupCreateOrConnectWithoutUserGroupInput {
  create: GroupCreateWithoutUserGroupInput!
  where: GroupWhereUniqueInput!
}

input GroupCreateOrConnectWithoutWorkbookInput {
  create: GroupCreateWithoutWorkbookInput!
  where: GroupWhereUniqueInput!
}

input GroupCreateWithoutContestInput {
  config: JSON!
  createTime: DateTime
  description: String!
  groupName: String!
  notice: NoticeCreateNestedManyWithoutGroupInput
  problem: ProblemCreateNestedManyWithoutGroupInput
  updateTime: DateTime
  userGroup: UserGroupCreateNestedManyWithoutGroupInput
  workbook: WorkbookCreateNestedManyWithoutGroupInput
}

input GroupCreateWithoutNoticeInput {
  config: JSON!
  contest: ContestCreateNestedManyWithoutGroupInput
  createTime: DateTime
  description: String!
  groupName: String!
  problem: ProblemCreateNestedManyWithoutGroupInput
  updateTime: DateTime
  userGroup: UserGroupCreateNestedManyWithoutGroupInput
  workbook: WorkbookCreateNestedManyWithoutGroupInput
}

input GroupCreateWithoutProblemInput {
  config: JSON!
  contest: ContestCreateNestedManyWithoutGroupInput
  createTime: DateTime
  description: String!
  groupName: String!
  notice: NoticeCreateNestedManyWithoutGroupInput
  updateTime: DateTime
  userGroup: UserGroupCreateNestedManyWithoutGroupInput
  workbook: WorkbookCreateNestedManyWithoutGroupInput
}

input GroupCreateWithoutUserGroupInput {
  config: JSON!
  contest: ContestCreateNestedManyWithoutGroupInput
  createTime: DateTime
  description: String!
  groupName: String!
  notice: NoticeCreateNestedManyWithoutGroupInput
  problem: ProblemCreateNestedManyWithoutGroupInput
  updateTime: DateTime
  workbook: WorkbookCreateNestedManyWithoutGroupInput
}

input GroupCreateWithoutWorkbookInput {
  config: JSON!
  contest: ContestCreateNestedManyWithoutGroupInput
  createTime: DateTime
  description: String!
  groupName: String!
  notice: NoticeCreateNestedManyWithoutGroupInput
  problem: ProblemCreateNestedManyWithoutGroupInput
  updateTime: DateTime
  userGroup: UserGroupCreateNestedManyWithoutGroupInput
}

type GroupMaxAggregate {
  createTime: DateTime
  description: String
  groupName: String
  id: Int
  updateTime: DateTime
}

type GroupMember {
  email: String!
  name: String!
  userId: Float!
  username: String!
}

type GroupMinAggregate {
  createTime: DateTime
  description: String
  groupName: String
  id: Int
  updateTime: DateTime
}

input GroupRelationFilter {
  is: GroupWhereInput
  isNot: GroupWhereInput
}

type GroupSumAggregate {
  id: Int
}

input GroupUpdateOneRequiredWithoutContestNestedInput {
  connect: GroupWhereUniqueInput
  connectOrCreate: GroupCreateOrConnectWithoutContestInput
  create: GroupCreateWithoutContestInput
  update: GroupUpdateToOneWithWhereWithoutContestInput
  upsert: GroupUpsertWithoutContestInput
}

input GroupUpdateOneRequiredWithoutNoticeNestedInput {
  connect: GroupWhereUniqueInput
  connectOrCreate: GroupCreateOrConnectWithoutNoticeInput
  create: GroupCreateWithoutNoticeInput
  update: GroupUpdateToOneWithWhereWithoutNoticeInput
  upsert: GroupUpsertWithoutNoticeInput
}

input GroupUpdateOneRequiredWithoutProblemNestedInput {
  connect: GroupWhereUniqueInput
  connectOrCreate: GroupCreateOrConnectWithoutProblemInput
  create: GroupCreateWithoutProblemInput
  update: GroupUpdateToOneWithWhereWithoutProblemInput
  upsert: GroupUpsertWithoutProblemInput
}

input GroupUpdateOneRequiredWithoutUserGroupNestedInput {
  connect: GroupWhereUniqueInput
  connectOrCreate: GroupCreateOrConnectWithoutUserGroupInput
  create: GroupCreateWithoutUserGroupInput
  update: GroupUpdateToOneWithWhereWithoutUserGroupInput
  upsert: GroupUpsertWithoutUserGroupInput
}

input GroupUpdateOneRequiredWithoutWorkbookNestedInput {
  connect: GroupWhereUniqueInput
  connectOrCreate: GroupCreateOrConnectWithoutWorkbookInput
  create: GroupCreateWithoutWorkbookInput
  update: GroupUpdateToOneWithWhereWithoutWorkbookInput
  upsert: GroupUpsertWithoutWorkbookInput
}

input GroupUpdateToOneWithWhereWithoutContestInput {
  data: GroupUpdateWithoutContestInput!
  where: GroupWhereInput
}

input GroupUpdateToOneWithWhereWithoutNoticeInput {
  data: GroupUpdateWithoutNoticeInput!
  where: GroupWhereInput
}

input GroupUpdateToOneWithWhereWithoutProblemInput {
  data: GroupUpdateWithoutProblemInput!
  where: GroupWhereInput
}

input GroupUpdateToOneWithWhereWithoutUserGroupInput {
  data: GroupUpdateWithoutUserGroupInput!
  where: GroupWhereInput
}

input GroupUpdateToOneWithWhereWithoutWorkbookInput {
  data: GroupUpdateWithoutWorkbookInput!
  where: GroupWhereInput
}

input GroupUpdateWithoutContestInput {
  config: JSON
  createTime: DateTime
  description: String
  groupName: String
  notice: NoticeUpdateManyWithoutGroupNestedInput
  problem: ProblemUpdateManyWithoutGroupNestedInput
  updateTime: DateTime
  userGroup: UserGroupUpdateManyWithoutGroupNestedInput
  workbook: WorkbookUpdateManyWithoutGroupNestedInput
}

input GroupUpdateWithoutNoticeInput {
  config: JSON
  contest: ContestUpdateManyWithoutGroupNestedInput
  createTime: DateTime
  description: String
  groupName: String
  problem: ProblemUpdateManyWithoutGroupNestedInput
  updateTime: DateTime
  userGroup: UserGroupUpdateManyWithoutGroupNestedInput
  workbook: WorkbookUpdateManyWithoutGroupNestedInput
}

input GroupUpdateWithoutProblemInput {
  config: JSON
  contest: ContestUpdateManyWithoutGroupNestedInput
  createTime: DateTime
  description: String
  groupName: String
  notice: NoticeUpdateManyWithoutGroupNestedInput
  updateTime: DateTime
  userGroup: UserGroupUpdateManyWithoutGroupNestedInput
  workbook: WorkbookUpdateManyWithoutGroupNestedInput
}

input GroupUpdateWithoutUserGroupInput {
  config: JSON
  contest: ContestUpdateManyWithoutGroupNestedInput
  createTime: DateTime
  description: String
  groupName: String
  notice: NoticeUpdateManyWithoutGroupNestedInput
  problem: ProblemUpdateManyWithoutGroupNestedInput
  updateTime: DateTime
  workbook: WorkbookUpdateManyWithoutGroupNestedInput
}

input GroupUpdateWithoutWorkbookInput {
  config: JSON
  contest: ContestUpdateManyWithoutGroupNestedInput
  createTime: DateTime
  description: String
  groupName: String
  notice: NoticeUpdateManyWithoutGroupNestedInput
  problem: ProblemUpdateManyWithoutGroupNestedInput
  updateTime: DateTime
  userGroup: UserGroupUpdateManyWithoutGroupNestedInput
}

input GroupUpsertWithoutContestInput {
  create: GroupCreateWithoutContestInput!
  update: GroupUpdateWithoutContestInput!
  where: GroupWhereInput
}

input GroupUpsertWithoutNoticeInput {
  create: GroupCreateWithoutNoticeInput!
  update: GroupUpdateWithoutNoticeInput!
  where: GroupWhereInput
}

input GroupUpsertWithoutProblemInput {
  create: GroupCreateWithoutProblemInput!
  update: GroupUpdateWithoutProblemInput!
  where: GroupWhereInput
}

input GroupUpsertWithoutUserGroupInput {
  create: GroupCreateWithoutUserGroupInput!
  update: GroupUpdateWithoutUserGroupInput!
  where: GroupWhereInput
}

input GroupUpsertWithoutWorkbookInput {
  create: GroupCreateWithoutWorkbookInput!
  update: GroupUpdateWithoutWorkbookInput!
  where: GroupWhereInput
}

input GroupWhereInput {
  AND: [GroupWhereInput!]
  NOT: [GroupWhereInput!]
  OR: [GroupWhereInput!]
  config: JsonFilter
  contest: ContestListRelationFilter
  createTime: DateTimeFilter
  description: StringFilter
  groupName: StringFilter
  id: IntFilter
  notice: NoticeListRelationFilter
  problem: ProblemListRelationFilter
  updateTime: DateTimeFilter
  userGroup: UserGroupListRelationFilter
  workbook: WorkbookListRelationFilter
}

input GroupWhereUniqueInput {
  AND: [GroupWhereInput!]
  NOT: [GroupWhereInput!]
  OR: [GroupWhereInput!]
  config: JsonFilter
  contest: ContestListRelationFilter
  createTime: DateTimeFilter
  description: StringFilter
  groupName: String
  id: Int
  notice: NoticeListRelationFilter
  problem: ProblemListRelationFilter
  updateTime: DateTimeFilter
  userGroup: UserGroupListRelationFilter
  workbook: WorkbookListRelationFilter
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

input JsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input JsonNullableListFilter {
  equals: [JSON!]
  has: JSON
  hasEvery: [JSON!]
  hasSome: [JSON!]
  isEmpty: Boolean
}

enum Language {
  C
  Cpp
  Golang
  Java
  Python2
  Python3
}

enum Level {
  Level1
  Level2
  Level3
  Level4
  Level5
}

type Mutation {
  createAnnouncement(createAnnouncementInput: AnnouncementInput!): Announcement!
  createContest(groupId: Int! = 1, input: CreateContestInput!): Contest!
  createGroup(input: CreateGroupInput!): Group!
  createNotice(groupId: Int, input: CreateNoticeInput!): Notice!
  createProblem(groupId: Int! = 1, input: CreateProblemInput!): Problem!
  createPublicizingRequest(contestId: Int!, groupId: Int!): PublicizingRequest!
  deleteContest(contestId: Int!, groupId: Int!): Contest!
  deleteGroup(groupId: Int!): DeletedUserGroup!
  deleteGroupMember(groupId: Int!, userId: Int!): UserGroup!
  deleteNotice(groupId: Int, noticeId: Int!): Notice!
  deleteProblem(groupId: Int! = 1, id: Int!): Problem!
  handleJoinRequest(groupId: Int!, isAccept: Boolean!, userId: Int!): UserGroup!
  handlePublicizingRequest(contestId: Int!, isAccepted: Boolean!): PublicizingResponse!
  importProblemsToContest(contestId: Int!, groupId: Int!, problemIds: [Int!]!): [ContestProblem!]!
  issueInvitation(groupId: Int!): String!
  removeAnnouncement(id: Int!): Announcement!
  revokeInvitation(groupId: Int!): String!
  updateAnnouncement(content: String!, id: Int!): Announcement!
  updateContest(groupId: Int!, input: UpdateContestInput!): Contest!
  updateContestProblemsOrder(contestId: Int!, groupId: Int! = 1, orders: [Int!]!): [ContestProblem!]!
  updateGroup(groupId: Int!, input: UpdateGroupInput!): Group!
  updateGroupMember(groupId: Int!, toGroupLeader: Boolean!, userId: Int!): UserGroup!
  updateNotice(groupId: Int, input: UpdateNoticeInput!, noticeId: Int!): Notice!
  updateProblem(groupId: Int! = 1, input: UpdateProblemInput!): Problem!
  updateWorkbookProblemsOrder(groupId: Int! = 1, orders: [Int!]!, workbookId: Int!): [WorkbookProblem!]!
  uploadProblems(groupId: Int! = 1, input: UploadFileInput!): [Problem!]!
}

input NestedBigIntFilter {
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedBigIntFilter
  notIn: [String!]
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedEnumLanguageFilter {
  equals: Language
  in: [Language!]
  not: NestedEnumLanguageFilter
  notIn: [Language!]
}

input NestedEnumLevelFilter {
  equals: Level
  in: [Level!]
  not: NestedEnumLevelFilter
  notIn: [Level!]
}

input NestedEnumProviderFilter {
  equals: Provider
  in: [Provider!]
  not: NestedEnumProviderFilter
  notIn: [Provider!]
}

input NestedEnumResultStatusFilter {
  equals: ResultStatus
  in: [ResultStatus!]
  not: NestedEnumResultStatusFilter
  notIn: [ResultStatus!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  search: String
  startsWith: String
}

type Notice {
  content: String!
  createTime: DateTime!
  createdBy: User!
  createdById: Int
  group: Group!
  groupId: Int!
  id: ID!
  isFixed: Boolean!
  isVisible: Boolean!
  title: String!
  updateTime: DateTime!
}

type NoticeAvgAggregate {
  createdById: Float
  groupId: Float
  id: Float
}

type NoticeCountAggregate {
  _all: Int!
  content: Int!
  createTime: Int!
  createdById: Int!
  groupId: Int!
  id: Int!
  isFixed: Int!
  isVisible: Int!
  title: Int!
  updateTime: Int!
}

input NoticeCreateManyCreatedByInput {
  content: String!
  createTime: DateTime
  groupId: Int!
  id: Int
  isFixed: Boolean
  isVisible: Boolean
  title: String!
  updateTime: DateTime
}

input NoticeCreateManyCreatedByInputEnvelope {
  data: [NoticeCreateManyCreatedByInput!]!
  skipDuplicates: Boolean
}

input NoticeCreateManyGroupInput {
  content: String!
  createTime: DateTime
  createdById: Int
  id: Int
  isFixed: Boolean
  isVisible: Boolean
  title: String!
  updateTime: DateTime
}

input NoticeCreateManyGroupInputEnvelope {
  data: [NoticeCreateManyGroupInput!]!
  skipDuplicates: Boolean
}

input NoticeCreateNestedManyWithoutCreatedByInput {
  connect: [NoticeWhereUniqueInput!]
  connectOrCreate: [NoticeCreateOrConnectWithoutCreatedByInput!]
  create: [NoticeCreateWithoutCreatedByInput!]
  createMany: NoticeCreateManyCreatedByInputEnvelope
}

input NoticeCreateNestedManyWithoutGroupInput {
  connect: [NoticeWhereUniqueInput!]
  connectOrCreate: [NoticeCreateOrConnectWithoutGroupInput!]
  create: [NoticeCreateWithoutGroupInput!]
  createMany: NoticeCreateManyGroupInputEnvelope
}

input NoticeCreateOrConnectWithoutCreatedByInput {
  create: NoticeCreateWithoutCreatedByInput!
  where: NoticeWhereUniqueInput!
}

input NoticeCreateOrConnectWithoutGroupInput {
  create: NoticeCreateWithoutGroupInput!
  where: NoticeWhereUniqueInput!
}

input NoticeCreateWithoutCreatedByInput {
  content: String!
  createTime: DateTime
  group: GroupCreateNestedOneWithoutNoticeInput!
  isFixed: Boolean
  isVisible: Boolean
  title: String!
  updateTime: DateTime
}

input NoticeCreateWithoutGroupInput {
  content: String!
  createTime: DateTime
  createdBy: UserCreateNestedOneWithoutNoticeInput
  isFixed: Boolean
  isVisible: Boolean
  title: String!
  updateTime: DateTime
}

input NoticeListRelationFilter {
  every: NoticeWhereInput
  none: NoticeWhereInput
  some: NoticeWhereInput
}

type NoticeMaxAggregate {
  content: String
  createTime: DateTime
  createdById: Int
  groupId: Int
  id: Int
  isFixed: Boolean
  isVisible: Boolean
  title: String
  updateTime: DateTime
}

type NoticeMinAggregate {
  content: String
  createTime: DateTime
  createdById: Int
  groupId: Int
  id: Int
  isFixed: Boolean
  isVisible: Boolean
  title: String
  updateTime: DateTime
}

input NoticeScalarWhereInput {
  AND: [NoticeScalarWhereInput!]
  NOT: [NoticeScalarWhereInput!]
  OR: [NoticeScalarWhereInput!]
  content: StringFilter
  createTime: DateTimeFilter
  createdById: IntNullableFilter
  groupId: IntFilter
  id: IntFilter
  isFixed: BoolFilter
  isVisible: BoolFilter
  title: StringFilter
  updateTime: DateTimeFilter
}

type NoticeSumAggregate {
  createdById: Int
  groupId: Int
  id: Int
}

input NoticeUpdateManyMutationInput {
  content: String
  createTime: DateTime
  isFixed: Boolean
  isVisible: Boolean
  title: String
  updateTime: DateTime
}

input NoticeUpdateManyWithWhereWithoutCreatedByInput {
  data: NoticeUpdateManyMutationInput!
  where: NoticeScalarWhereInput!
}

input NoticeUpdateManyWithWhereWithoutGroupInput {
  data: NoticeUpdateManyMutationInput!
  where: NoticeScalarWhereInput!
}

input NoticeUpdateManyWithoutCreatedByNestedInput {
  connect: [NoticeWhereUniqueInput!]
  connectOrCreate: [NoticeCreateOrConnectWithoutCreatedByInput!]
  create: [NoticeCreateWithoutCreatedByInput!]
  createMany: NoticeCreateManyCreatedByInputEnvelope
  delete: [NoticeWhereUniqueInput!]
  deleteMany: [NoticeScalarWhereInput!]
  disconnect: [NoticeWhereUniqueInput!]
  set: [NoticeWhereUniqueInput!]
  update: [NoticeUpdateWithWhereUniqueWithoutCreatedByInput!]
  updateMany: [NoticeUpdateManyWithWhereWithoutCreatedByInput!]
  upsert: [NoticeUpsertWithWhereUniqueWithoutCreatedByInput!]
}

input NoticeUpdateManyWithoutGroupNestedInput {
  connect: [NoticeWhereUniqueInput!]
  connectOrCreate: [NoticeCreateOrConnectWithoutGroupInput!]
  create: [NoticeCreateWithoutGroupInput!]
  createMany: NoticeCreateManyGroupInputEnvelope
  delete: [NoticeWhereUniqueInput!]
  deleteMany: [NoticeScalarWhereInput!]
  disconnect: [NoticeWhereUniqueInput!]
  set: [NoticeWhereUniqueInput!]
  update: [NoticeUpdateWithWhereUniqueWithoutGroupInput!]
  updateMany: [NoticeUpdateManyWithWhereWithoutGroupInput!]
  upsert: [NoticeUpsertWithWhereUniqueWithoutGroupInput!]
}

input NoticeUpdateWithWhereUniqueWithoutCreatedByInput {
  data: NoticeUpdateWithoutCreatedByInput!
  where: NoticeWhereUniqueInput!
}

input NoticeUpdateWithWhereUniqueWithoutGroupInput {
  data: NoticeUpdateWithoutGroupInput!
  where: NoticeWhereUniqueInput!
}

input NoticeUpdateWithoutCreatedByInput {
  content: String
  createTime: DateTime
  group: GroupUpdateOneRequiredWithoutNoticeNestedInput
  isFixed: Boolean
  isVisible: Boolean
  title: String
  updateTime: DateTime
}

input NoticeUpdateWithoutGroupInput {
  content: String
  createTime: DateTime
  createdBy: UserUpdateOneWithoutNoticeNestedInput
  isFixed: Boolean
  isVisible: Boolean
  title: String
  updateTime: DateTime
}

input NoticeUpsertWithWhereUniqueWithoutCreatedByInput {
  create: NoticeCreateWithoutCreatedByInput!
  update: NoticeUpdateWithoutCreatedByInput!
  where: NoticeWhereUniqueInput!
}

input NoticeUpsertWithWhereUniqueWithoutGroupInput {
  create: NoticeCreateWithoutGroupInput!
  update: NoticeUpdateWithoutGroupInput!
  where: NoticeWhereUniqueInput!
}

input NoticeWhereInput {
  AND: [NoticeWhereInput!]
  NOT: [NoticeWhereInput!]
  OR: [NoticeWhereInput!]
  content: StringFilter
  createTime: DateTimeFilter
  createdBy: UserNullableRelationFilter
  createdById: IntNullableFilter
  group: GroupRelationFilter
  groupId: IntFilter
  id: IntFilter
  isFixed: BoolFilter
  isVisible: BoolFilter
  title: StringFilter
  updateTime: DateTimeFilter
}

input NoticeWhereUniqueInput {
  AND: [NoticeWhereInput!]
  NOT: [NoticeWhereInput!]
  OR: [NoticeWhereInput!]
  content: StringFilter
  createTime: DateTimeFilter
  createdBy: UserNullableRelationFilter
  createdById: IntNullableFilter
  group: GroupRelationFilter
  groupId: IntFilter
  id: Int
  isFixed: BoolFilter
  isVisible: BoolFilter
  title: StringFilter
  updateTime: DateTimeFilter
}

type Problem {
  _count: ProblemCount!
  acceptedCount: Int!
  acceptedRate: Float!
  announcement: [Announcement!]
  codeDraft: [CodeDraft!]
  contestProblem: [ContestProblem!]
  createTime: DateTime!
  createdBy: User
  createdById: Int
  description: String!
  difficulty: Level!
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime!
  group: Group!
  groupId: Int!
  hint: String!
  id: ID!
  inputDescription: String!

  """
  template code item structure
  {
  "lanaguage": Language,
  "code": {
  "id": number,
  "text": string,
  "locked": boolean
  }[]
  }
  """
  isVisible: Boolean!
  languages: [Language!]
  memoryLimit: Int!
  outputDescription: String!
  problemTag: [ProblemTag!]
  problemTestcase: [ProblemTestcase!]
  samples: [ExampleIO!]
  source: String!
  submission: [Submission!]
  submissionCount: Int!
  tag: [ProblemTag!]!
  template: [JSON!]
  testcase: [ProblemTestcase!]!
  timeLimit: Int!
  title: String!
  updateTime: DateTime!
  workbookProblem: [WorkbookProblem!]
}

type ProblemAvgAggregate {
  acceptedCount: Float
  acceptedRate: Float
  createdById: Float
  groupId: Float
  id: Float
  memoryLimit: Float
  submissionCount: Float
  timeLimit: Float
}

type ProblemCount {
  announcement: Int!
  codeDraft: Int!
  contestProblem: Int!
  problemTag: Int!
  problemTestcase: Int!
  samples: Int!
  submission: Int!
  workbookProblem: Int!
}

type ProblemCountAggregate {
  _all: Int!
  acceptedCount: Int!
  acceptedRate: Int!
  createTime: Int!
  createdById: Int!
  description: Int!
  difficulty: Int!
  engDescription: Int!
  engHint: Int!
  engInputDescription: Int!
  engOutputDescription: Int!
  engTitle: Int!
  exposeTime: Int!
  groupId: Int!
  hint: Int!
  id: Int!
  inputDescription: Int!
  isVisible: Int!
  languages: Int!
  memoryLimit: Int!
  outputDescription: Int!
  source: Int!
  submissionCount: Int!
  template: Int!
  timeLimit: Int!
  title: Int!
  updateTime: Int!
}

input ProblemCreateManyCreatedByInput {
  acceptedCount: Int
  acceptedRate: Float
  createTime: DateTime
  description: String!
  difficulty: Level!
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  groupId: Int!
  hint: String!
  id: Int
  inputDescription: String!
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int!
  outputDescription: String!
  source: String!
  submissionCount: Int
  template: [JSON!]
  timeLimit: Int!
  title: String!
  updateTime: DateTime
}

input ProblemCreateManyCreatedByInputEnvelope {
  data: [ProblemCreateManyCreatedByInput!]!
  skipDuplicates: Boolean
}

input ProblemCreateManyGroupInput {
  acceptedCount: Int
  acceptedRate: Float
  createTime: DateTime
  createdById: Int
  description: String!
  difficulty: Level!
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  hint: String!
  id: Int
  inputDescription: String!
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int!
  outputDescription: String!
  source: String!
  submissionCount: Int
  template: [JSON!]
  timeLimit: Int!
  title: String!
  updateTime: DateTime
}

input ProblemCreateManyGroupInputEnvelope {
  data: [ProblemCreateManyGroupInput!]!
  skipDuplicates: Boolean
}

input ProblemCreateNestedManyWithoutCreatedByInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutCreatedByInput!]
  create: [ProblemCreateWithoutCreatedByInput!]
  createMany: ProblemCreateManyCreatedByInputEnvelope
}

input ProblemCreateNestedManyWithoutGroupInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutGroupInput!]
  create: [ProblemCreateWithoutGroupInput!]
  createMany: ProblemCreateManyGroupInputEnvelope
}

input ProblemCreateNestedOneWithoutAnnouncementInput {
  connect: ProblemWhereUniqueInput
  connectOrCreate: ProblemCreateOrConnectWithoutAnnouncementInput
  create: ProblemCreateWithoutAnnouncementInput
}

input ProblemCreateNestedOneWithoutCodeDraftInput {
  connect: ProblemWhereUniqueInput
  connectOrCreate: ProblemCreateOrConnectWithoutCodeDraftInput
  create: ProblemCreateWithoutCodeDraftInput
}

input ProblemCreateNestedOneWithoutContestProblemInput {
  connect: ProblemWhereUniqueInput
  connectOrCreate: ProblemCreateOrConnectWithoutContestProblemInput
  create: ProblemCreateWithoutContestProblemInput
}

input ProblemCreateNestedOneWithoutProblemTestcaseInput {
  connect: ProblemWhereUniqueInput
  connectOrCreate: ProblemCreateOrConnectWithoutProblemTestcaseInput
  create: ProblemCreateWithoutProblemTestcaseInput
}

input ProblemCreateNestedOneWithoutSubmissionInput {
  connect: ProblemWhereUniqueInput
  connectOrCreate: ProblemCreateOrConnectWithoutSubmissionInput
  create: ProblemCreateWithoutSubmissionInput
}

input ProblemCreateNestedOneWithoutWorkbookProblemInput {
  connect: ProblemWhereUniqueInput
  connectOrCreate: ProblemCreateOrConnectWithoutWorkbookProblemInput
  create: ProblemCreateWithoutWorkbookProblemInput
}

input ProblemCreateOrConnectWithoutAnnouncementInput {
  create: ProblemCreateWithoutAnnouncementInput!
  where: ProblemWhereUniqueInput!
}

input ProblemCreateOrConnectWithoutCodeDraftInput {
  create: ProblemCreateWithoutCodeDraftInput!
  where: ProblemWhereUniqueInput!
}

input ProblemCreateOrConnectWithoutContestProblemInput {
  create: ProblemCreateWithoutContestProblemInput!
  where: ProblemWhereUniqueInput!
}

input ProblemCreateOrConnectWithoutCreatedByInput {
  create: ProblemCreateWithoutCreatedByInput!
  where: ProblemWhereUniqueInput!
}

input ProblemCreateOrConnectWithoutGroupInput {
  create: ProblemCreateWithoutGroupInput!
  where: ProblemWhereUniqueInput!
}

input ProblemCreateOrConnectWithoutProblemTestcaseInput {
  create: ProblemCreateWithoutProblemTestcaseInput!
  where: ProblemWhereUniqueInput!
}

input ProblemCreateOrConnectWithoutSubmissionInput {
  create: ProblemCreateWithoutSubmissionInput!
  where: ProblemWhereUniqueInput!
}

input ProblemCreateOrConnectWithoutWorkbookProblemInput {
  create: ProblemCreateWithoutWorkbookProblemInput!
  where: ProblemWhereUniqueInput!
}

input ProblemCreateWithoutAnnouncementInput {
  acceptedCount: Int
  acceptedRate: Float
  codeDraft: CodeDraftCreateNestedManyWithoutProblemInput
  contestProblem: ContestProblemCreateNestedManyWithoutProblemInput
  createTime: DateTime
  createdBy: UserCreateNestedOneWithoutProblemInput
  description: String!
  difficulty: Level!
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  group: GroupCreateNestedOneWithoutProblemInput!
  hint: String!
  inputDescription: String!
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int!
  outputDescription: String!
  problemTag: ProblemTagCreateNestedManyWithoutProblemInput
  problemTestcase: ProblemTestcaseCreateNestedManyWithoutProblemInput
  samples: ExampleIOCreateNestedManyWithoutProblemInput
  source: String!
  submission: SubmissionCreateNestedManyWithoutProblemInput
  submissionCount: Int
  template: [JSON!]
  timeLimit: Int!
  title: String!
  updateTime: DateTime
  workbookProblem: WorkbookProblemCreateNestedManyWithoutProblemInput
}

input ProblemCreateWithoutCodeDraftInput {
  acceptedCount: Int
  acceptedRate: Float
  announcement: AnnouncementCreateNestedManyWithoutProblemInput
  contestProblem: ContestProblemCreateNestedManyWithoutProblemInput
  createTime: DateTime
  createdBy: UserCreateNestedOneWithoutProblemInput
  description: String!
  difficulty: Level!
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  group: GroupCreateNestedOneWithoutProblemInput!
  hint: String!
  inputDescription: String!
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int!
  outputDescription: String!
  problemTag: ProblemTagCreateNestedManyWithoutProblemInput
  problemTestcase: ProblemTestcaseCreateNestedManyWithoutProblemInput
  samples: ExampleIOCreateNestedManyWithoutProblemInput
  source: String!
  submission: SubmissionCreateNestedManyWithoutProblemInput
  submissionCount: Int
  template: [JSON!]
  timeLimit: Int!
  title: String!
  updateTime: DateTime
  workbookProblem: WorkbookProblemCreateNestedManyWithoutProblemInput
}

input ProblemCreateWithoutContestProblemInput {
  acceptedCount: Int
  acceptedRate: Float
  announcement: AnnouncementCreateNestedManyWithoutProblemInput
  codeDraft: CodeDraftCreateNestedManyWithoutProblemInput
  createTime: DateTime
  createdBy: UserCreateNestedOneWithoutProblemInput
  description: String!
  difficulty: Level!
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  group: GroupCreateNestedOneWithoutProblemInput!
  hint: String!
  inputDescription: String!
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int!
  outputDescription: String!
  problemTag: ProblemTagCreateNestedManyWithoutProblemInput
  problemTestcase: ProblemTestcaseCreateNestedManyWithoutProblemInput
  samples: ExampleIOCreateNestedManyWithoutProblemInput
  source: String!
  submission: SubmissionCreateNestedManyWithoutProblemInput
  submissionCount: Int
  template: [JSON!]
  timeLimit: Int!
  title: String!
  updateTime: DateTime
  workbookProblem: WorkbookProblemCreateNestedManyWithoutProblemInput
}

input ProblemCreateWithoutCreatedByInput {
  acceptedCount: Int
  acceptedRate: Float
  announcement: AnnouncementCreateNestedManyWithoutProblemInput
  codeDraft: CodeDraftCreateNestedManyWithoutProblemInput
  contestProblem: ContestProblemCreateNestedManyWithoutProblemInput
  createTime: DateTime
  description: String!
  difficulty: Level!
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  group: GroupCreateNestedOneWithoutProblemInput!
  hint: String!
  inputDescription: String!
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int!
  outputDescription: String!
  problemTag: ProblemTagCreateNestedManyWithoutProblemInput
  problemTestcase: ProblemTestcaseCreateNestedManyWithoutProblemInput
  samples: ExampleIOCreateNestedManyWithoutProblemInput
  source: String!
  submission: SubmissionCreateNestedManyWithoutProblemInput
  submissionCount: Int
  template: [JSON!]
  timeLimit: Int!
  title: String!
  updateTime: DateTime
  workbookProblem: WorkbookProblemCreateNestedManyWithoutProblemInput
}

input ProblemCreateWithoutGroupInput {
  acceptedCount: Int
  acceptedRate: Float
  announcement: AnnouncementCreateNestedManyWithoutProblemInput
  codeDraft: CodeDraftCreateNestedManyWithoutProblemInput
  contestProblem: ContestProblemCreateNestedManyWithoutProblemInput
  createTime: DateTime
  createdBy: UserCreateNestedOneWithoutProblemInput
  description: String!
  difficulty: Level!
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  hint: String!
  inputDescription: String!
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int!
  outputDescription: String!
  problemTag: ProblemTagCreateNestedManyWithoutProblemInput
  problemTestcase: ProblemTestcaseCreateNestedManyWithoutProblemInput
  samples: ExampleIOCreateNestedManyWithoutProblemInput
  source: String!
  submission: SubmissionCreateNestedManyWithoutProblemInput
  submissionCount: Int
  template: [JSON!]
  timeLimit: Int!
  title: String!
  updateTime: DateTime
  workbookProblem: WorkbookProblemCreateNestedManyWithoutProblemInput
}

input ProblemCreateWithoutProblemTestcaseInput {
  acceptedCount: Int
  acceptedRate: Float
  announcement: AnnouncementCreateNestedManyWithoutProblemInput
  codeDraft: CodeDraftCreateNestedManyWithoutProblemInput
  contestProblem: ContestProblemCreateNestedManyWithoutProblemInput
  createTime: DateTime
  createdBy: UserCreateNestedOneWithoutProblemInput
  description: String!
  difficulty: Level!
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  group: GroupCreateNestedOneWithoutProblemInput!
  hint: String!
  inputDescription: String!
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int!
  outputDescription: String!
  problemTag: ProblemTagCreateNestedManyWithoutProblemInput
  samples: ExampleIOCreateNestedManyWithoutProblemInput
  source: String!
  submission: SubmissionCreateNestedManyWithoutProblemInput
  submissionCount: Int
  template: [JSON!]
  timeLimit: Int!
  title: String!
  updateTime: DateTime
  workbookProblem: WorkbookProblemCreateNestedManyWithoutProblemInput
}

input ProblemCreateWithoutSubmissionInput {
  acceptedCount: Int
  acceptedRate: Float
  announcement: AnnouncementCreateNestedManyWithoutProblemInput
  codeDraft: CodeDraftCreateNestedManyWithoutProblemInput
  contestProblem: ContestProblemCreateNestedManyWithoutProblemInput
  createTime: DateTime
  createdBy: UserCreateNestedOneWithoutProblemInput
  description: String!
  difficulty: Level!
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  group: GroupCreateNestedOneWithoutProblemInput!
  hint: String!
  inputDescription: String!
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int!
  outputDescription: String!
  problemTag: ProblemTagCreateNestedManyWithoutProblemInput
  problemTestcase: ProblemTestcaseCreateNestedManyWithoutProblemInput
  samples: ExampleIOCreateNestedManyWithoutProblemInput
  source: String!
  submissionCount: Int
  template: [JSON!]
  timeLimit: Int!
  title: String!
  updateTime: DateTime
  workbookProblem: WorkbookProblemCreateNestedManyWithoutProblemInput
}

input ProblemCreateWithoutWorkbookProblemInput {
  acceptedCount: Int
  acceptedRate: Float
  announcement: AnnouncementCreateNestedManyWithoutProblemInput
  codeDraft: CodeDraftCreateNestedManyWithoutProblemInput
  contestProblem: ContestProblemCreateNestedManyWithoutProblemInput
  createTime: DateTime
  createdBy: UserCreateNestedOneWithoutProblemInput
  description: String!
  difficulty: Level!
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  group: GroupCreateNestedOneWithoutProblemInput!
  hint: String!
  inputDescription: String!
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int!
  outputDescription: String!
  problemTag: ProblemTagCreateNestedManyWithoutProblemInput
  problemTestcase: ProblemTestcaseCreateNestedManyWithoutProblemInput
  samples: ExampleIOCreateNestedManyWithoutProblemInput
  source: String!
  submission: SubmissionCreateNestedManyWithoutProblemInput
  submissionCount: Int
  template: [JSON!]
  timeLimit: Int!
  title: String!
  updateTime: DateTime
}

input ProblemListRelationFilter {
  every: ProblemWhereInput
  none: ProblemWhereInput
  some: ProblemWhereInput
}

type ProblemMaxAggregate {
  acceptedCount: Int
  acceptedRate: Float
  createTime: DateTime
  createdById: Int
  description: String
  difficulty: Level
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  groupId: Int
  hint: String
  id: Int
  inputDescription: String
  isVisible: Boolean
  memoryLimit: Int
  outputDescription: String
  source: String
  submissionCount: Int
  timeLimit: Int
  title: String
  updateTime: DateTime
}

type ProblemMinAggregate {
  acceptedCount: Int
  acceptedRate: Float
  createTime: DateTime
  createdById: Int
  description: String
  difficulty: Level
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  groupId: Int
  hint: String
  id: Int
  inputDescription: String
  isVisible: Boolean
  memoryLimit: Int
  outputDescription: String
  source: String
  submissionCount: Int
  timeLimit: Int
  title: String
  updateTime: DateTime
}

input ProblemNullableRelationFilter {
  is: ProblemWhereInput
  isNot: ProblemWhereInput
}

input ProblemRelationFilter {
  is: ProblemWhereInput
  isNot: ProblemWhereInput
}

input ProblemScalarWhereInput {
  AND: [ProblemScalarWhereInput!]
  NOT: [ProblemScalarWhereInput!]
  OR: [ProblemScalarWhereInput!]
  acceptedCount: IntFilter
  acceptedRate: FloatFilter
  createTime: DateTimeFilter
  createdById: IntNullableFilter
  description: StringFilter
  difficulty: EnumLevelFilter
  engDescription: StringNullableFilter
  engHint: StringNullableFilter
  engInputDescription: StringNullableFilter
  engOutputDescription: StringNullableFilter
  engTitle: StringNullableFilter
  exposeTime: DateTimeFilter
  groupId: IntFilter
  hint: StringFilter
  id: IntFilter
  inputDescription: StringFilter
  isVisible: BoolFilter
  languages: EnumLanguageNullableListFilter
  memoryLimit: IntFilter
  outputDescription: StringFilter
  source: StringFilter
  submissionCount: IntFilter
  template: JsonNullableListFilter
  timeLimit: IntFilter
  title: StringFilter
  updateTime: DateTimeFilter
}

type ProblemSumAggregate {
  acceptedCount: Int
  acceptedRate: Float
  createdById: Int
  groupId: Int
  id: Int
  memoryLimit: Int
  submissionCount: Int
  timeLimit: Int
}

type ProblemTag {
  id: ID!
  problem: Problem!
  problemId: Int!
  tag: Tag!
  tagId: Int!
}

type ProblemTagAvgAggregate {
  id: Float
  problemId: Float
  tagId: Float
}

type ProblemTagCountAggregate {
  _all: Int!
  id: Int!
  problemId: Int!
  tagId: Int!
}

input ProblemTagCreateManyProblemInput {
  id: Int
  tagId: Int!
}

input ProblemTagCreateManyProblemInputEnvelope {
  data: [ProblemTagCreateManyProblemInput!]!
  skipDuplicates: Boolean
}

input ProblemTagCreateNestedManyWithoutProblemInput {
  connect: [ProblemTagWhereUniqueInput!]
  connectOrCreate: [ProblemTagCreateOrConnectWithoutProblemInput!]
  create: [ProblemTagCreateWithoutProblemInput!]
  createMany: ProblemTagCreateManyProblemInputEnvelope
}

input ProblemTagCreateOrConnectWithoutProblemInput {
  create: ProblemTagCreateWithoutProblemInput!
  where: ProblemTagWhereUniqueInput!
}

input ProblemTagCreateWithoutProblemInput {
  tag: TagCreateNestedOneWithoutProblemTagInput!
}

input ProblemTagListRelationFilter {
  every: ProblemTagWhereInput
  none: ProblemTagWhereInput
  some: ProblemTagWhereInput
}

type ProblemTagMaxAggregate {
  id: Int
  problemId: Int
  tagId: Int
}

type ProblemTagMinAggregate {
  id: Int
  problemId: Int
  tagId: Int
}

input ProblemTagScalarWhereInput {
  AND: [ProblemTagScalarWhereInput!]
  NOT: [ProblemTagScalarWhereInput!]
  OR: [ProblemTagScalarWhereInput!]
  id: IntFilter
  problemId: IntFilter
  tagId: IntFilter
}

type ProblemTagSumAggregate {
  id: Int
  problemId: Int
  tagId: Int
}

input ProblemTagUncheckedUpdateManyWithoutProblemInput {
  id: Int
  tagId: Int
}

input ProblemTagUpdateManyWithWhereWithoutProblemInput {
  data: ProblemTagUncheckedUpdateManyWithoutProblemInput!
  where: ProblemTagScalarWhereInput!
}

input ProblemTagUpdateManyWithoutProblemNestedInput {
  connect: [ProblemTagWhereUniqueInput!]
  connectOrCreate: [ProblemTagCreateOrConnectWithoutProblemInput!]
  create: [ProblemTagCreateWithoutProblemInput!]
  createMany: ProblemTagCreateManyProblemInputEnvelope
  delete: [ProblemTagWhereUniqueInput!]
  deleteMany: [ProblemTagScalarWhereInput!]
  disconnect: [ProblemTagWhereUniqueInput!]
  set: [ProblemTagWhereUniqueInput!]
  update: [ProblemTagUpdateWithWhereUniqueWithoutProblemInput!]
  updateMany: [ProblemTagUpdateManyWithWhereWithoutProblemInput!]
  upsert: [ProblemTagUpsertWithWhereUniqueWithoutProblemInput!]
}

input ProblemTagUpdateWithWhereUniqueWithoutProblemInput {
  data: ProblemTagUpdateWithoutProblemInput!
  where: ProblemTagWhereUniqueInput!
}

input ProblemTagUpdateWithoutProblemInput {
  tag: TagUpdateOneRequiredWithoutProblemTagNestedInput
}

input ProblemTagUpsertWithWhereUniqueWithoutProblemInput {
  create: ProblemTagCreateWithoutProblemInput!
  update: ProblemTagUpdateWithoutProblemInput!
  where: ProblemTagWhereUniqueInput!
}

input ProblemTagWhereInput {
  AND: [ProblemTagWhereInput!]
  NOT: [ProblemTagWhereInput!]
  OR: [ProblemTagWhereInput!]
  id: IntFilter
  problem: ProblemRelationFilter
  problemId: IntFilter
  tag: TagRelationFilter
  tagId: IntFilter
}

input ProblemTagWhereUniqueInput {
  AND: [ProblemTagWhereInput!]
  NOT: [ProblemTagWhereInput!]
  OR: [ProblemTagWhereInput!]
  id: Int
  problem: ProblemRelationFilter
  problemId: IntFilter
  tag: TagRelationFilter
  tagId: IntFilter
}

type ProblemTestcase {
  _count: ProblemTestcaseCount!
  createTime: DateTime!
  id: ID!
  input: String!
  output: String!
  problem: Problem!
  problemId: Int!
  scoreWeight: Int!
  submissionResult: [SubmissionResult!]
  updateTime: DateTime!
}

type ProblemTestcaseAvgAggregate {
  id: Float
  problemId: Float
  scoreWeight: Float
}

type ProblemTestcaseCount {
  submissionResult: Int!
}

type ProblemTestcaseCountAggregate {
  _all: Int!
  createTime: Int!
  id: Int!
  input: Int!
  output: Int!
  problemId: Int!
  scoreWeight: Int!
  updateTime: Int!
}

input ProblemTestcaseCreateManyProblemInput {
  createTime: DateTime
  id: Int
  input: String!
  output: String!
  scoreWeight: Int
  updateTime: DateTime
}

input ProblemTestcaseCreateManyProblemInputEnvelope {
  data: [ProblemTestcaseCreateManyProblemInput!]!
  skipDuplicates: Boolean
}

input ProblemTestcaseCreateNestedManyWithoutProblemInput {
  connect: [ProblemTestcaseWhereUniqueInput!]
  connectOrCreate: [ProblemTestcaseCreateOrConnectWithoutProblemInput!]
  create: [ProblemTestcaseCreateWithoutProblemInput!]
  createMany: ProblemTestcaseCreateManyProblemInputEnvelope
}

input ProblemTestcaseCreateNestedOneWithoutSubmissionResultInput {
  connect: ProblemTestcaseWhereUniqueInput
  connectOrCreate: ProblemTestcaseCreateOrConnectWithoutSubmissionResultInput
  create: ProblemTestcaseCreateWithoutSubmissionResultInput
}

input ProblemTestcaseCreateOrConnectWithoutProblemInput {
  create: ProblemTestcaseCreateWithoutProblemInput!
  where: ProblemTestcaseWhereUniqueInput!
}

input ProblemTestcaseCreateOrConnectWithoutSubmissionResultInput {
  create: ProblemTestcaseCreateWithoutSubmissionResultInput!
  where: ProblemTestcaseWhereUniqueInput!
}

input ProblemTestcaseCreateWithoutProblemInput {
  createTime: DateTime
  input: String!
  output: String!
  scoreWeight: Int
  submissionResult: SubmissionResultCreateNestedManyWithoutProblemTestcaseInput
  updateTime: DateTime
}

input ProblemTestcaseCreateWithoutSubmissionResultInput {
  createTime: DateTime
  input: String!
  output: String!
  problem: ProblemCreateNestedOneWithoutProblemTestcaseInput!
  scoreWeight: Int
  updateTime: DateTime
}

input ProblemTestcaseListRelationFilter {
  every: ProblemTestcaseWhereInput
  none: ProblemTestcaseWhereInput
  some: ProblemTestcaseWhereInput
}

type ProblemTestcaseMaxAggregate {
  createTime: DateTime
  id: Int
  input: String
  output: String
  problemId: Int
  scoreWeight: Int
  updateTime: DateTime
}

type ProblemTestcaseMinAggregate {
  createTime: DateTime
  id: Int
  input: String
  output: String
  problemId: Int
  scoreWeight: Int
  updateTime: DateTime
}

input ProblemTestcaseRelationFilter {
  is: ProblemTestcaseWhereInput
  isNot: ProblemTestcaseWhereInput
}

input ProblemTestcaseScalarWhereInput {
  AND: [ProblemTestcaseScalarWhereInput!]
  NOT: [ProblemTestcaseScalarWhereInput!]
  OR: [ProblemTestcaseScalarWhereInput!]
  createTime: DateTimeFilter
  id: IntFilter
  input: StringFilter
  output: StringFilter
  problemId: IntFilter
  scoreWeight: IntFilter
  updateTime: DateTimeFilter
}

type ProblemTestcaseSumAggregate {
  id: Int
  problemId: Int
  scoreWeight: Int
}

input ProblemTestcaseUpdateManyMutationInput {
  createTime: DateTime
  input: String
  output: String
  scoreWeight: Int
  updateTime: DateTime
}

input ProblemTestcaseUpdateManyWithWhereWithoutProblemInput {
  data: ProblemTestcaseUpdateManyMutationInput!
  where: ProblemTestcaseScalarWhereInput!
}

input ProblemTestcaseUpdateManyWithoutProblemNestedInput {
  connect: [ProblemTestcaseWhereUniqueInput!]
  connectOrCreate: [ProblemTestcaseCreateOrConnectWithoutProblemInput!]
  create: [ProblemTestcaseCreateWithoutProblemInput!]
  createMany: ProblemTestcaseCreateManyProblemInputEnvelope
  delete: [ProblemTestcaseWhereUniqueInput!]
  deleteMany: [ProblemTestcaseScalarWhereInput!]
  disconnect: [ProblemTestcaseWhereUniqueInput!]
  set: [ProblemTestcaseWhereUniqueInput!]
  update: [ProblemTestcaseUpdateWithWhereUniqueWithoutProblemInput!]
  updateMany: [ProblemTestcaseUpdateManyWithWhereWithoutProblemInput!]
  upsert: [ProblemTestcaseUpsertWithWhereUniqueWithoutProblemInput!]
}

input ProblemTestcaseUpdateOneRequiredWithoutSubmissionResultNestedInput {
  connect: ProblemTestcaseWhereUniqueInput
  connectOrCreate: ProblemTestcaseCreateOrConnectWithoutSubmissionResultInput
  create: ProblemTestcaseCreateWithoutSubmissionResultInput
  update: ProblemTestcaseUpdateToOneWithWhereWithoutSubmissionResultInput
  upsert: ProblemTestcaseUpsertWithoutSubmissionResultInput
}

input ProblemTestcaseUpdateToOneWithWhereWithoutSubmissionResultInput {
  data: ProblemTestcaseUpdateWithoutSubmissionResultInput!
  where: ProblemTestcaseWhereInput
}

input ProblemTestcaseUpdateWithWhereUniqueWithoutProblemInput {
  data: ProblemTestcaseUpdateWithoutProblemInput!
  where: ProblemTestcaseWhereUniqueInput!
}

input ProblemTestcaseUpdateWithoutProblemInput {
  createTime: DateTime
  input: String
  output: String
  scoreWeight: Int
  submissionResult: SubmissionResultUpdateManyWithoutProblemTestcaseNestedInput
  updateTime: DateTime
}

input ProblemTestcaseUpdateWithoutSubmissionResultInput {
  createTime: DateTime
  input: String
  output: String
  problem: ProblemUpdateOneRequiredWithoutProblemTestcaseNestedInput
  scoreWeight: Int
  updateTime: DateTime
}

input ProblemTestcaseUpsertWithWhereUniqueWithoutProblemInput {
  create: ProblemTestcaseCreateWithoutProblemInput!
  update: ProblemTestcaseUpdateWithoutProblemInput!
  where: ProblemTestcaseWhereUniqueInput!
}

input ProblemTestcaseUpsertWithoutSubmissionResultInput {
  create: ProblemTestcaseCreateWithoutSubmissionResultInput!
  update: ProblemTestcaseUpdateWithoutSubmissionResultInput!
  where: ProblemTestcaseWhereInput
}

input ProblemTestcaseWhereInput {
  AND: [ProblemTestcaseWhereInput!]
  NOT: [ProblemTestcaseWhereInput!]
  OR: [ProblemTestcaseWhereInput!]
  createTime: DateTimeFilter
  id: IntFilter
  input: StringFilter
  output: StringFilter
  problem: ProblemRelationFilter
  problemId: IntFilter
  scoreWeight: IntFilter
  submissionResult: SubmissionResultListRelationFilter
  updateTime: DateTimeFilter
}

input ProblemTestcaseWhereUniqueInput {
  AND: [ProblemTestcaseWhereInput!]
  NOT: [ProblemTestcaseWhereInput!]
  OR: [ProblemTestcaseWhereInput!]
  createTime: DateTimeFilter
  id: Int
  input: StringFilter
  output: StringFilter
  problem: ProblemRelationFilter
  problemId: IntFilter
  scoreWeight: IntFilter
  submissionResult: SubmissionResultListRelationFilter
  updateTime: DateTimeFilter
}

input ProblemUpdateManyMutationInput {
  acceptedCount: Int
  acceptedRate: Float
  createTime: DateTime
  description: String
  difficulty: Level
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  hint: String
  inputDescription: String
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int
  outputDescription: String
  source: String
  submissionCount: Int
  template: [JSON!]
  timeLimit: Int
  title: String
  updateTime: DateTime
}

input ProblemUpdateManyWithWhereWithoutCreatedByInput {
  data: ProblemUpdateManyMutationInput!
  where: ProblemScalarWhereInput!
}

input ProblemUpdateManyWithWhereWithoutGroupInput {
  data: ProblemUpdateManyMutationInput!
  where: ProblemScalarWhereInput!
}

input ProblemUpdateManyWithoutCreatedByNestedInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutCreatedByInput!]
  create: [ProblemCreateWithoutCreatedByInput!]
  createMany: ProblemCreateManyCreatedByInputEnvelope
  delete: [ProblemWhereUniqueInput!]
  deleteMany: [ProblemScalarWhereInput!]
  disconnect: [ProblemWhereUniqueInput!]
  set: [ProblemWhereUniqueInput!]
  update: [ProblemUpdateWithWhereUniqueWithoutCreatedByInput!]
  updateMany: [ProblemUpdateManyWithWhereWithoutCreatedByInput!]
  upsert: [ProblemUpsertWithWhereUniqueWithoutCreatedByInput!]
}

input ProblemUpdateManyWithoutGroupNestedInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutGroupInput!]
  create: [ProblemCreateWithoutGroupInput!]
  createMany: ProblemCreateManyGroupInputEnvelope
  delete: [ProblemWhereUniqueInput!]
  deleteMany: [ProblemScalarWhereInput!]
  disconnect: [ProblemWhereUniqueInput!]
  set: [ProblemWhereUniqueInput!]
  update: [ProblemUpdateWithWhereUniqueWithoutGroupInput!]
  updateMany: [ProblemUpdateManyWithWhereWithoutGroupInput!]
  upsert: [ProblemUpsertWithWhereUniqueWithoutGroupInput!]
}

input ProblemUpdateOneRequiredWithoutCodeDraftNestedInput {
  connect: ProblemWhereUniqueInput
  connectOrCreate: ProblemCreateOrConnectWithoutCodeDraftInput
  create: ProblemCreateWithoutCodeDraftInput
  update: ProblemUpdateToOneWithWhereWithoutCodeDraftInput
  upsert: ProblemUpsertWithoutCodeDraftInput
}

input ProblemUpdateOneRequiredWithoutContestProblemNestedInput {
  connect: ProblemWhereUniqueInput
  connectOrCreate: ProblemCreateOrConnectWithoutContestProblemInput
  create: ProblemCreateWithoutContestProblemInput
  update: ProblemUpdateToOneWithWhereWithoutContestProblemInput
  upsert: ProblemUpsertWithoutContestProblemInput
}

input ProblemUpdateOneRequiredWithoutProblemTestcaseNestedInput {
  connect: ProblemWhereUniqueInput
  connectOrCreate: ProblemCreateOrConnectWithoutProblemTestcaseInput
  create: ProblemCreateWithoutProblemTestcaseInput
  update: ProblemUpdateToOneWithWhereWithoutProblemTestcaseInput
  upsert: ProblemUpsertWithoutProblemTestcaseInput
}

input ProblemUpdateOneRequiredWithoutSubmissionNestedInput {
  connect: ProblemWhereUniqueInput
  connectOrCreate: ProblemCreateOrConnectWithoutSubmissionInput
  create: ProblemCreateWithoutSubmissionInput
  update: ProblemUpdateToOneWithWhereWithoutSubmissionInput
  upsert: ProblemUpsertWithoutSubmissionInput
}

input ProblemUpdateOneRequiredWithoutWorkbookProblemNestedInput {
  connect: ProblemWhereUniqueInput
  connectOrCreate: ProblemCreateOrConnectWithoutWorkbookProblemInput
  create: ProblemCreateWithoutWorkbookProblemInput
  update: ProblemUpdateToOneWithWhereWithoutWorkbookProblemInput
  upsert: ProblemUpsertWithoutWorkbookProblemInput
}

input ProblemUpdateOneWithoutAnnouncementNestedInput {
  connect: ProblemWhereUniqueInput
  connectOrCreate: ProblemCreateOrConnectWithoutAnnouncementInput
  create: ProblemCreateWithoutAnnouncementInput
  delete: ProblemWhereInput
  disconnect: ProblemWhereInput
  update: ProblemUpdateToOneWithWhereWithoutAnnouncementInput
  upsert: ProblemUpsertWithoutAnnouncementInput
}

input ProblemUpdateToOneWithWhereWithoutAnnouncementInput {
  data: ProblemUpdateWithoutAnnouncementInput!
  where: ProblemWhereInput
}

input ProblemUpdateToOneWithWhereWithoutCodeDraftInput {
  data: ProblemUpdateWithoutCodeDraftInput!
  where: ProblemWhereInput
}

input ProblemUpdateToOneWithWhereWithoutContestProblemInput {
  data: ProblemUpdateWithoutContestProblemInput!
  where: ProblemWhereInput
}

input ProblemUpdateToOneWithWhereWithoutProblemTestcaseInput {
  data: ProblemUpdateWithoutProblemTestcaseInput!
  where: ProblemWhereInput
}

input ProblemUpdateToOneWithWhereWithoutSubmissionInput {
  data: ProblemUpdateWithoutSubmissionInput!
  where: ProblemWhereInput
}

input ProblemUpdateToOneWithWhereWithoutWorkbookProblemInput {
  data: ProblemUpdateWithoutWorkbookProblemInput!
  where: ProblemWhereInput
}

input ProblemUpdateWithWhereUniqueWithoutCreatedByInput {
  data: ProblemUpdateWithoutCreatedByInput!
  where: ProblemWhereUniqueInput!
}

input ProblemUpdateWithWhereUniqueWithoutGroupInput {
  data: ProblemUpdateWithoutGroupInput!
  where: ProblemWhereUniqueInput!
}

input ProblemUpdateWithoutAnnouncementInput {
  acceptedCount: Int
  acceptedRate: Float
  codeDraft: CodeDraftUpdateManyWithoutProblemNestedInput
  contestProblem: ContestProblemUpdateManyWithoutProblemNestedInput
  createTime: DateTime
  createdBy: UserUpdateOneWithoutProblemNestedInput
  description: String
  difficulty: Level
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  group: GroupUpdateOneRequiredWithoutProblemNestedInput
  hint: String
  inputDescription: String
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int
  outputDescription: String
  problemTag: ProblemTagUpdateManyWithoutProblemNestedInput
  problemTestcase: ProblemTestcaseUpdateManyWithoutProblemNestedInput
  samples: ExampleIOUpdateManyWithoutProblemNestedInput
  source: String
  submission: SubmissionUpdateManyWithoutProblemNestedInput
  submissionCount: Int
  template: [JSON!]
  timeLimit: Int
  title: String
  updateTime: DateTime
  workbookProblem: WorkbookProblemUpdateManyWithoutProblemNestedInput
}

input ProblemUpdateWithoutCodeDraftInput {
  acceptedCount: Int
  acceptedRate: Float
  announcement: AnnouncementUpdateManyWithoutProblemNestedInput
  contestProblem: ContestProblemUpdateManyWithoutProblemNestedInput
  createTime: DateTime
  createdBy: UserUpdateOneWithoutProblemNestedInput
  description: String
  difficulty: Level
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  group: GroupUpdateOneRequiredWithoutProblemNestedInput
  hint: String
  inputDescription: String
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int
  outputDescription: String
  problemTag: ProblemTagUpdateManyWithoutProblemNestedInput
  problemTestcase: ProblemTestcaseUpdateManyWithoutProblemNestedInput
  samples: ExampleIOUpdateManyWithoutProblemNestedInput
  source: String
  submission: SubmissionUpdateManyWithoutProblemNestedInput
  submissionCount: Int
  template: [JSON!]
  timeLimit: Int
  title: String
  updateTime: DateTime
  workbookProblem: WorkbookProblemUpdateManyWithoutProblemNestedInput
}

input ProblemUpdateWithoutContestProblemInput {
  acceptedCount: Int
  acceptedRate: Float
  announcement: AnnouncementUpdateManyWithoutProblemNestedInput
  codeDraft: CodeDraftUpdateManyWithoutProblemNestedInput
  createTime: DateTime
  createdBy: UserUpdateOneWithoutProblemNestedInput
  description: String
  difficulty: Level
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  group: GroupUpdateOneRequiredWithoutProblemNestedInput
  hint: String
  inputDescription: String
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int
  outputDescription: String
  problemTag: ProblemTagUpdateManyWithoutProblemNestedInput
  problemTestcase: ProblemTestcaseUpdateManyWithoutProblemNestedInput
  samples: ExampleIOUpdateManyWithoutProblemNestedInput
  source: String
  submission: SubmissionUpdateManyWithoutProblemNestedInput
  submissionCount: Int
  template: [JSON!]
  timeLimit: Int
  title: String
  updateTime: DateTime
  workbookProblem: WorkbookProblemUpdateManyWithoutProblemNestedInput
}

input ProblemUpdateWithoutCreatedByInput {
  acceptedCount: Int
  acceptedRate: Float
  announcement: AnnouncementUpdateManyWithoutProblemNestedInput
  codeDraft: CodeDraftUpdateManyWithoutProblemNestedInput
  contestProblem: ContestProblemUpdateManyWithoutProblemNestedInput
  createTime: DateTime
  description: String
  difficulty: Level
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  group: GroupUpdateOneRequiredWithoutProblemNestedInput
  hint: String
  inputDescription: String
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int
  outputDescription: String
  problemTag: ProblemTagUpdateManyWithoutProblemNestedInput
  problemTestcase: ProblemTestcaseUpdateManyWithoutProblemNestedInput
  samples: ExampleIOUpdateManyWithoutProblemNestedInput
  source: String
  submission: SubmissionUpdateManyWithoutProblemNestedInput
  submissionCount: Int
  template: [JSON!]
  timeLimit: Int
  title: String
  updateTime: DateTime
  workbookProblem: WorkbookProblemUpdateManyWithoutProblemNestedInput
}

input ProblemUpdateWithoutGroupInput {
  acceptedCount: Int
  acceptedRate: Float
  announcement: AnnouncementUpdateManyWithoutProblemNestedInput
  codeDraft: CodeDraftUpdateManyWithoutProblemNestedInput
  contestProblem: ContestProblemUpdateManyWithoutProblemNestedInput
  createTime: DateTime
  createdBy: UserUpdateOneWithoutProblemNestedInput
  description: String
  difficulty: Level
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  hint: String
  inputDescription: String
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int
  outputDescription: String
  problemTag: ProblemTagUpdateManyWithoutProblemNestedInput
  problemTestcase: ProblemTestcaseUpdateManyWithoutProblemNestedInput
  samples: ExampleIOUpdateManyWithoutProblemNestedInput
  source: String
  submission: SubmissionUpdateManyWithoutProblemNestedInput
  submissionCount: Int
  template: [JSON!]
  timeLimit: Int
  title: String
  updateTime: DateTime
  workbookProblem: WorkbookProblemUpdateManyWithoutProblemNestedInput
}

input ProblemUpdateWithoutProblemTestcaseInput {
  acceptedCount: Int
  acceptedRate: Float
  announcement: AnnouncementUpdateManyWithoutProblemNestedInput
  codeDraft: CodeDraftUpdateManyWithoutProblemNestedInput
  contestProblem: ContestProblemUpdateManyWithoutProblemNestedInput
  createTime: DateTime
  createdBy: UserUpdateOneWithoutProblemNestedInput
  description: String
  difficulty: Level
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  group: GroupUpdateOneRequiredWithoutProblemNestedInput
  hint: String
  inputDescription: String
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int
  outputDescription: String
  problemTag: ProblemTagUpdateManyWithoutProblemNestedInput
  samples: ExampleIOUpdateManyWithoutProblemNestedInput
  source: String
  submission: SubmissionUpdateManyWithoutProblemNestedInput
  submissionCount: Int
  template: [JSON!]
  timeLimit: Int
  title: String
  updateTime: DateTime
  workbookProblem: WorkbookProblemUpdateManyWithoutProblemNestedInput
}

input ProblemUpdateWithoutSubmissionInput {
  acceptedCount: Int
  acceptedRate: Float
  announcement: AnnouncementUpdateManyWithoutProblemNestedInput
  codeDraft: CodeDraftUpdateManyWithoutProblemNestedInput
  contestProblem: ContestProblemUpdateManyWithoutProblemNestedInput
  createTime: DateTime
  createdBy: UserUpdateOneWithoutProblemNestedInput
  description: String
  difficulty: Level
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  group: GroupUpdateOneRequiredWithoutProblemNestedInput
  hint: String
  inputDescription: String
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int
  outputDescription: String
  problemTag: ProblemTagUpdateManyWithoutProblemNestedInput
  problemTestcase: ProblemTestcaseUpdateManyWithoutProblemNestedInput
  samples: ExampleIOUpdateManyWithoutProblemNestedInput
  source: String
  submissionCount: Int
  template: [JSON!]
  timeLimit: Int
  title: String
  updateTime: DateTime
  workbookProblem: WorkbookProblemUpdateManyWithoutProblemNestedInput
}

input ProblemUpdateWithoutWorkbookProblemInput {
  acceptedCount: Int
  acceptedRate: Float
  announcement: AnnouncementUpdateManyWithoutProblemNestedInput
  codeDraft: CodeDraftUpdateManyWithoutProblemNestedInput
  contestProblem: ContestProblemUpdateManyWithoutProblemNestedInput
  createTime: DateTime
  createdBy: UserUpdateOneWithoutProblemNestedInput
  description: String
  difficulty: Level
  engDescription: String
  engHint: String
  engInputDescription: String
  engOutputDescription: String
  engTitle: String
  exposeTime: DateTime
  group: GroupUpdateOneRequiredWithoutProblemNestedInput
  hint: String
  inputDescription: String
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int
  outputDescription: String
  problemTag: ProblemTagUpdateManyWithoutProblemNestedInput
  problemTestcase: ProblemTestcaseUpdateManyWithoutProblemNestedInput
  samples: ExampleIOUpdateManyWithoutProblemNestedInput
  source: String
  submission: SubmissionUpdateManyWithoutProblemNestedInput
  submissionCount: Int
  template: [JSON!]
  timeLimit: Int
  title: String
  updateTime: DateTime
}

input ProblemUpsertWithWhereUniqueWithoutCreatedByInput {
  create: ProblemCreateWithoutCreatedByInput!
  update: ProblemUpdateWithoutCreatedByInput!
  where: ProblemWhereUniqueInput!
}

input ProblemUpsertWithWhereUniqueWithoutGroupInput {
  create: ProblemCreateWithoutGroupInput!
  update: ProblemUpdateWithoutGroupInput!
  where: ProblemWhereUniqueInput!
}

input ProblemUpsertWithoutAnnouncementInput {
  create: ProblemCreateWithoutAnnouncementInput!
  update: ProblemUpdateWithoutAnnouncementInput!
  where: ProblemWhereInput
}

input ProblemUpsertWithoutCodeDraftInput {
  create: ProblemCreateWithoutCodeDraftInput!
  update: ProblemUpdateWithoutCodeDraftInput!
  where: ProblemWhereInput
}

input ProblemUpsertWithoutContestProblemInput {
  create: ProblemCreateWithoutContestProblemInput!
  update: ProblemUpdateWithoutContestProblemInput!
  where: ProblemWhereInput
}

input ProblemUpsertWithoutProblemTestcaseInput {
  create: ProblemCreateWithoutProblemTestcaseInput!
  update: ProblemUpdateWithoutProblemTestcaseInput!
  where: ProblemWhereInput
}

input ProblemUpsertWithoutSubmissionInput {
  create: ProblemCreateWithoutSubmissionInput!
  update: ProblemUpdateWithoutSubmissionInput!
  where: ProblemWhereInput
}

input ProblemUpsertWithoutWorkbookProblemInput {
  create: ProblemCreateWithoutWorkbookProblemInput!
  update: ProblemUpdateWithoutWorkbookProblemInput!
  where: ProblemWhereInput
}

input ProblemWhereInput {
  AND: [ProblemWhereInput!]
  NOT: [ProblemWhereInput!]
  OR: [ProblemWhereInput!]
  acceptedCount: IntFilter
  acceptedRate: FloatFilter
  announcement: AnnouncementListRelationFilter
  codeDraft: CodeDraftListRelationFilter
  contestProblem: ContestProblemListRelationFilter
  createTime: DateTimeFilter
  createdBy: UserNullableRelationFilter
  createdById: IntNullableFilter
  description: StringFilter
  difficulty: EnumLevelFilter
  engDescription: StringNullableFilter
  engHint: StringNullableFilter
  engInputDescription: StringNullableFilter
  engOutputDescription: StringNullableFilter
  engTitle: StringNullableFilter
  exposeTime: DateTimeFilter
  group: GroupRelationFilter
  groupId: IntFilter
  hint: StringFilter
  id: IntFilter
  inputDescription: StringFilter
  isVisible: BoolFilter
  languages: EnumLanguageNullableListFilter
  memoryLimit: IntFilter
  outputDescription: StringFilter
  problemTag: ProblemTagListRelationFilter
  problemTestcase: ProblemTestcaseListRelationFilter
  samples: ExampleIOListRelationFilter
  source: StringFilter
  submission: SubmissionListRelationFilter
  submissionCount: IntFilter
  template: JsonNullableListFilter
  timeLimit: IntFilter
  title: StringFilter
  updateTime: DateTimeFilter
  workbookProblem: WorkbookProblemListRelationFilter
}

input ProblemWhereUniqueInput {
  AND: [ProblemWhereInput!]
  NOT: [ProblemWhereInput!]
  OR: [ProblemWhereInput!]
  acceptedCount: IntFilter
  acceptedRate: FloatFilter
  announcement: AnnouncementListRelationFilter
  codeDraft: CodeDraftListRelationFilter
  contestProblem: ContestProblemListRelationFilter
  createTime: DateTimeFilter
  createdBy: UserNullableRelationFilter
  createdById: IntNullableFilter
  description: StringFilter
  difficulty: EnumLevelFilter
  engDescription: StringNullableFilter
  engHint: StringNullableFilter
  engInputDescription: StringNullableFilter
  engOutputDescription: StringNullableFilter
  engTitle: StringNullableFilter
  exposeTime: DateTimeFilter
  group: GroupRelationFilter
  groupId: IntFilter
  hint: StringFilter
  id: Int
  inputDescription: StringFilter
  isVisible: BoolFilter
  languages: EnumLanguageNullableListFilter
  memoryLimit: IntFilter
  outputDescription: StringFilter
  problemTag: ProblemTagListRelationFilter
  problemTestcase: ProblemTestcaseListRelationFilter
  samples: ExampleIOListRelationFilter
  source: StringFilter
  submission: SubmissionListRelationFilter
  submissionCount: IntFilter
  template: JsonNullableListFilter
  timeLimit: IntFilter
  title: StringFilter
  updateTime: DateTimeFilter
  workbookProblem: WorkbookProblemListRelationFilter
}

enum Provider {
  github
  google
  kakao
  naver
}

"""publicizingRequest"""
type PublicizingRequest {
  contestId: Int!
  expireTime: String!
  userId: Int!
}

type PublicizingResponse {
  contestId: Int!
  isAccepted: Boolean!
}

type Query {
  getAnnouncementById(id: Int!): Announcement!
  getAnnouncements(contestId: Int!, problemId: Int): [Announcement!]!
  getContest(contestId: Int!): ContestWithParticipants!
  getContestProblems(contestId: Int!, groupId: Int! = 1): [ContestProblem!]!
  getContests(cursor: Int, groupId: Int! = 1, take: Int! = 10): [ContestWithParticipants!]!
  getGroup(groupId: Int!): FindGroup!
  getGroupMembers(cursor: Int, groupId: Int! = 1, leaderOnly: Boolean! = false, take: Int! = 10): [GroupMember!]!
  getGroups(cursor: Int, take: Int! = 10): [FindGroup!]!
  getJoinRequests(groupId: Int!): [User!]!
  getNotice(groupId: Int, noticeId: Int!): Notice!
  getNotices(cursor: Int, groupId: Int, take: Int! = 10): [Notice]!
  getProblem(groupId: Int! = 1, id: Int!): Problem!
  getProblems(cursor: Int, groupId: Int! = 1, input: FilterProblemsInput!, take: Int! = 10): [Problem!]!
  getPublicizingRequests: [PublicizingRequest!]!
  getTags: [Tag!]!
  getWorkbookProblems(groupId: Int! = 1, workbookId: Int!): [WorkbookProblem!]!
}

enum QueryMode {
  default
  insensitive
}

enum ResultStatus {
  Accepted
  CompileError
  Judging
  MemoryLimitExceeded
  OutputLimitExceeded
  RuntimeError
  ServerError
  TimeLimitExceeded
  WrongAnswer
}

enum Role {
  Admin
  Manager
  SuperAdmin
  User
}

input Sample {
  input: String!
  output: String!
}

input Snippet {
  id: Int!
  locked: Boolean!
  text: String!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  search: String
  startsWith: String
}

type Submission {
  _count: SubmissionCount!

  """
  code item structure
  {
  "id": number,
  "text": string,
  "locked": boolean
  }
  """
  code: [JSON!]
  codeSize: Int
  contest: Contest
  contestId: Int
  createTime: DateTime!
  id: ID!
  language: Language!
  problem: Problem!
  problemId: Int!
  result: ResultStatus!
  submissionResult: [SubmissionResult!]
  updateTime: DateTime!
  user: User
  userId: Int
  workbook: Workbook
  workbookId: Int
}

type SubmissionAvgAggregate {
  codeSize: Float
  contestId: Float
  id: Float
  problemId: Float
  userId: Float
  workbookId: Float
}

type SubmissionCount {
  submissionResult: Int!
}

type SubmissionCountAggregate {
  _all: Int!
  code: Int!
  codeSize: Int!
  contestId: Int!
  createTime: Int!
  id: Int!
  language: Int!
  problemId: Int!
  result: Int!
  updateTime: Int!
  userId: Int!
  workbookId: Int!
}

input SubmissionCreateManyContestInput {
  code: [JSON!]
  codeSize: Int
  createTime: DateTime
  id: Int
  language: Language!
  problemId: Int!
  result: ResultStatus!
  updateTime: DateTime
  userId: Int
  workbookId: Int
}

input SubmissionCreateManyContestInputEnvelope {
  data: [SubmissionCreateManyContestInput!]!
  skipDuplicates: Boolean
}

input SubmissionCreateManyProblemInput {
  code: [JSON!]
  codeSize: Int
  contestId: Int
  createTime: DateTime
  id: Int
  language: Language!
  result: ResultStatus!
  updateTime: DateTime
  userId: Int
  workbookId: Int
}

input SubmissionCreateManyProblemInputEnvelope {
  data: [SubmissionCreateManyProblemInput!]!
  skipDuplicates: Boolean
}

input SubmissionCreateManyUserInput {
  code: [JSON!]
  codeSize: Int
  contestId: Int
  createTime: DateTime
  id: Int
  language: Language!
  problemId: Int!
  result: ResultStatus!
  updateTime: DateTime
  workbookId: Int
}

input SubmissionCreateManyUserInputEnvelope {
  data: [SubmissionCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input SubmissionCreateManyWorkbookInput {
  code: [JSON!]
  codeSize: Int
  contestId: Int
  createTime: DateTime
  id: Int
  language: Language!
  problemId: Int!
  result: ResultStatus!
  updateTime: DateTime
  userId: Int
}

input SubmissionCreateManyWorkbookInputEnvelope {
  data: [SubmissionCreateManyWorkbookInput!]!
  skipDuplicates: Boolean
}

input SubmissionCreateNestedManyWithoutContestInput {
  connect: [SubmissionWhereUniqueInput!]
  connectOrCreate: [SubmissionCreateOrConnectWithoutContestInput!]
  create: [SubmissionCreateWithoutContestInput!]
  createMany: SubmissionCreateManyContestInputEnvelope
}

input SubmissionCreateNestedManyWithoutProblemInput {
  connect: [SubmissionWhereUniqueInput!]
  connectOrCreate: [SubmissionCreateOrConnectWithoutProblemInput!]
  create: [SubmissionCreateWithoutProblemInput!]
  createMany: SubmissionCreateManyProblemInputEnvelope
}

input SubmissionCreateNestedManyWithoutUserInput {
  connect: [SubmissionWhereUniqueInput!]
  connectOrCreate: [SubmissionCreateOrConnectWithoutUserInput!]
  create: [SubmissionCreateWithoutUserInput!]
  createMany: SubmissionCreateManyUserInputEnvelope
}

input SubmissionCreateNestedManyWithoutWorkbookInput {
  connect: [SubmissionWhereUniqueInput!]
  connectOrCreate: [SubmissionCreateOrConnectWithoutWorkbookInput!]
  create: [SubmissionCreateWithoutWorkbookInput!]
  createMany: SubmissionCreateManyWorkbookInputEnvelope
}

input SubmissionCreateNestedOneWithoutSubmissionResultInput {
  connect: SubmissionWhereUniqueInput
  connectOrCreate: SubmissionCreateOrConnectWithoutSubmissionResultInput
  create: SubmissionCreateWithoutSubmissionResultInput
}

input SubmissionCreateOrConnectWithoutContestInput {
  create: SubmissionCreateWithoutContestInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionCreateOrConnectWithoutProblemInput {
  create: SubmissionCreateWithoutProblemInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionCreateOrConnectWithoutSubmissionResultInput {
  create: SubmissionCreateWithoutSubmissionResultInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionCreateOrConnectWithoutUserInput {
  create: SubmissionCreateWithoutUserInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionCreateOrConnectWithoutWorkbookInput {
  create: SubmissionCreateWithoutWorkbookInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionCreateWithoutContestInput {
  code: [JSON!]
  codeSize: Int
  createTime: DateTime
  language: Language!
  problem: ProblemCreateNestedOneWithoutSubmissionInput!
  result: ResultStatus!
  submissionResult: SubmissionResultCreateNestedManyWithoutSubmissionInput
  updateTime: DateTime
  user: UserCreateNestedOneWithoutSubmissionInput
  workbook: WorkbookCreateNestedOneWithoutSubmissionInput
}

input SubmissionCreateWithoutProblemInput {
  code: [JSON!]
  codeSize: Int
  contest: ContestCreateNestedOneWithoutSubmissionInput
  createTime: DateTime
  language: Language!
  result: ResultStatus!
  submissionResult: SubmissionResultCreateNestedManyWithoutSubmissionInput
  updateTime: DateTime
  user: UserCreateNestedOneWithoutSubmissionInput
  workbook: WorkbookCreateNestedOneWithoutSubmissionInput
}

input SubmissionCreateWithoutSubmissionResultInput {
  code: [JSON!]
  codeSize: Int
  contest: ContestCreateNestedOneWithoutSubmissionInput
  createTime: DateTime
  language: Language!
  problem: ProblemCreateNestedOneWithoutSubmissionInput!
  result: ResultStatus!
  updateTime: DateTime
  user: UserCreateNestedOneWithoutSubmissionInput
  workbook: WorkbookCreateNestedOneWithoutSubmissionInput
}

input SubmissionCreateWithoutUserInput {
  code: [JSON!]
  codeSize: Int
  contest: ContestCreateNestedOneWithoutSubmissionInput
  createTime: DateTime
  language: Language!
  problem: ProblemCreateNestedOneWithoutSubmissionInput!
  result: ResultStatus!
  submissionResult: SubmissionResultCreateNestedManyWithoutSubmissionInput
  updateTime: DateTime
  workbook: WorkbookCreateNestedOneWithoutSubmissionInput
}

input SubmissionCreateWithoutWorkbookInput {
  code: [JSON!]
  codeSize: Int
  contest: ContestCreateNestedOneWithoutSubmissionInput
  createTime: DateTime
  language: Language!
  problem: ProblemCreateNestedOneWithoutSubmissionInput!
  result: ResultStatus!
  submissionResult: SubmissionResultCreateNestedManyWithoutSubmissionInput
  updateTime: DateTime
  user: UserCreateNestedOneWithoutSubmissionInput
}

input SubmissionListRelationFilter {
  every: SubmissionWhereInput
  none: SubmissionWhereInput
  some: SubmissionWhereInput
}

type SubmissionMaxAggregate {
  codeSize: Int
  contestId: Int
  createTime: DateTime
  id: Int
  language: Language
  problemId: Int
  result: ResultStatus
  updateTime: DateTime
  userId: Int
  workbookId: Int
}

type SubmissionMinAggregate {
  codeSize: Int
  contestId: Int
  createTime: DateTime
  id: Int
  language: Language
  problemId: Int
  result: ResultStatus
  updateTime: DateTime
  userId: Int
  workbookId: Int
}

input SubmissionRelationFilter {
  is: SubmissionWhereInput
  isNot: SubmissionWhereInput
}

type SubmissionResult {
  cpuTime: String!
  createTime: DateTime!
  id: ID!
  memoryUsage: Int!
  problemTestcase: ProblemTestcase!
  problemTestcaseId: Int!
  result: ResultStatus!
  submission: Submission!
  submissionId: Int!
  updateTime: DateTime!
}

type SubmissionResultAvgAggregate {
  cpuTime: Float
  id: Float
  memoryUsage: Float
  problemTestcaseId: Float
  submissionId: Float
}

type SubmissionResultCountAggregate {
  _all: Int!
  cpuTime: Int!
  createTime: Int!
  id: Int!
  memoryUsage: Int!
  problemTestcaseId: Int!
  result: Int!
  submissionId: Int!
  updateTime: Int!
}

input SubmissionResultCreateManyProblemTestcaseInput {
  cpuTime: String!
  createTime: DateTime
  id: Int
  memoryUsage: Int!
  result: ResultStatus!
  submissionId: Int!
  updateTime: DateTime
}

input SubmissionResultCreateManyProblemTestcaseInputEnvelope {
  data: [SubmissionResultCreateManyProblemTestcaseInput!]!
  skipDuplicates: Boolean
}

input SubmissionResultCreateManySubmissionInput {
  cpuTime: String!
  createTime: DateTime
  id: Int
  memoryUsage: Int!
  problemTestcaseId: Int!
  result: ResultStatus!
  updateTime: DateTime
}

input SubmissionResultCreateManySubmissionInputEnvelope {
  data: [SubmissionResultCreateManySubmissionInput!]!
  skipDuplicates: Boolean
}

input SubmissionResultCreateNestedManyWithoutProblemTestcaseInput {
  connect: [SubmissionResultWhereUniqueInput!]
  connectOrCreate: [SubmissionResultCreateOrConnectWithoutProblemTestcaseInput!]
  create: [SubmissionResultCreateWithoutProblemTestcaseInput!]
  createMany: SubmissionResultCreateManyProblemTestcaseInputEnvelope
}

input SubmissionResultCreateNestedManyWithoutSubmissionInput {
  connect: [SubmissionResultWhereUniqueInput!]
  connectOrCreate: [SubmissionResultCreateOrConnectWithoutSubmissionInput!]
  create: [SubmissionResultCreateWithoutSubmissionInput!]
  createMany: SubmissionResultCreateManySubmissionInputEnvelope
}

input SubmissionResultCreateOrConnectWithoutProblemTestcaseInput {
  create: SubmissionResultCreateWithoutProblemTestcaseInput!
  where: SubmissionResultWhereUniqueInput!
}

input SubmissionResultCreateOrConnectWithoutSubmissionInput {
  create: SubmissionResultCreateWithoutSubmissionInput!
  where: SubmissionResultWhereUniqueInput!
}

input SubmissionResultCreateWithoutProblemTestcaseInput {
  cpuTime: String!
  createTime: DateTime
  memoryUsage: Int!
  result: ResultStatus!
  submission: SubmissionCreateNestedOneWithoutSubmissionResultInput!
  updateTime: DateTime
}

input SubmissionResultCreateWithoutSubmissionInput {
  cpuTime: String!
  createTime: DateTime
  memoryUsage: Int!
  problemTestcase: ProblemTestcaseCreateNestedOneWithoutSubmissionResultInput!
  result: ResultStatus!
  updateTime: DateTime
}

input SubmissionResultListRelationFilter {
  every: SubmissionResultWhereInput
  none: SubmissionResultWhereInput
  some: SubmissionResultWhereInput
}

type SubmissionResultMaxAggregate {
  cpuTime: String
  createTime: DateTime
  id: Int
  memoryUsage: Int
  problemTestcaseId: Int
  result: ResultStatus
  submissionId: Int
  updateTime: DateTime
}

type SubmissionResultMinAggregate {
  cpuTime: String
  createTime: DateTime
  id: Int
  memoryUsage: Int
  problemTestcaseId: Int
  result: ResultStatus
  submissionId: Int
  updateTime: DateTime
}

input SubmissionResultScalarWhereInput {
  AND: [SubmissionResultScalarWhereInput!]
  NOT: [SubmissionResultScalarWhereInput!]
  OR: [SubmissionResultScalarWhereInput!]
  cpuTime: BigIntFilter
  createTime: DateTimeFilter
  id: IntFilter
  memoryUsage: IntFilter
  problemTestcaseId: IntFilter
  result: EnumResultStatusFilter
  submissionId: IntFilter
  updateTime: DateTimeFilter
}

type SubmissionResultSumAggregate {
  cpuTime: String
  id: Int
  memoryUsage: Int
  problemTestcaseId: Int
  submissionId: Int
}

input SubmissionResultUpdateManyMutationInput {
  cpuTime: String
  createTime: DateTime
  memoryUsage: Int
  result: ResultStatus
  updateTime: DateTime
}

input SubmissionResultUpdateManyWithWhereWithoutProblemTestcaseInput {
  data: SubmissionResultUpdateManyMutationInput!
  where: SubmissionResultScalarWhereInput!
}

input SubmissionResultUpdateManyWithWhereWithoutSubmissionInput {
  data: SubmissionResultUpdateManyMutationInput!
  where: SubmissionResultScalarWhereInput!
}

input SubmissionResultUpdateManyWithoutProblemTestcaseNestedInput {
  connect: [SubmissionResultWhereUniqueInput!]
  connectOrCreate: [SubmissionResultCreateOrConnectWithoutProblemTestcaseInput!]
  create: [SubmissionResultCreateWithoutProblemTestcaseInput!]
  createMany: SubmissionResultCreateManyProblemTestcaseInputEnvelope
  delete: [SubmissionResultWhereUniqueInput!]
  deleteMany: [SubmissionResultScalarWhereInput!]
  disconnect: [SubmissionResultWhereUniqueInput!]
  set: [SubmissionResultWhereUniqueInput!]
  update: [SubmissionResultUpdateWithWhereUniqueWithoutProblemTestcaseInput!]
  updateMany: [SubmissionResultUpdateManyWithWhereWithoutProblemTestcaseInput!]
  upsert: [SubmissionResultUpsertWithWhereUniqueWithoutProblemTestcaseInput!]
}

input SubmissionResultUpdateManyWithoutSubmissionNestedInput {
  connect: [SubmissionResultWhereUniqueInput!]
  connectOrCreate: [SubmissionResultCreateOrConnectWithoutSubmissionInput!]
  create: [SubmissionResultCreateWithoutSubmissionInput!]
  createMany: SubmissionResultCreateManySubmissionInputEnvelope
  delete: [SubmissionResultWhereUniqueInput!]
  deleteMany: [SubmissionResultScalarWhereInput!]
  disconnect: [SubmissionResultWhereUniqueInput!]
  set: [SubmissionResultWhereUniqueInput!]
  update: [SubmissionResultUpdateWithWhereUniqueWithoutSubmissionInput!]
  updateMany: [SubmissionResultUpdateManyWithWhereWithoutSubmissionInput!]
  upsert: [SubmissionResultUpsertWithWhereUniqueWithoutSubmissionInput!]
}

input SubmissionResultUpdateWithWhereUniqueWithoutProblemTestcaseInput {
  data: SubmissionResultUpdateWithoutProblemTestcaseInput!
  where: SubmissionResultWhereUniqueInput!
}

input SubmissionResultUpdateWithWhereUniqueWithoutSubmissionInput {
  data: SubmissionResultUpdateWithoutSubmissionInput!
  where: SubmissionResultWhereUniqueInput!
}

input SubmissionResultUpdateWithoutProblemTestcaseInput {
  cpuTime: String
  createTime: DateTime
  memoryUsage: Int
  result: ResultStatus
  submission: SubmissionUpdateOneRequiredWithoutSubmissionResultNestedInput
  updateTime: DateTime
}

input SubmissionResultUpdateWithoutSubmissionInput {
  cpuTime: String
  createTime: DateTime
  memoryUsage: Int
  problemTestcase: ProblemTestcaseUpdateOneRequiredWithoutSubmissionResultNestedInput
  result: ResultStatus
  updateTime: DateTime
}

input SubmissionResultUpsertWithWhereUniqueWithoutProblemTestcaseInput {
  create: SubmissionResultCreateWithoutProblemTestcaseInput!
  update: SubmissionResultUpdateWithoutProblemTestcaseInput!
  where: SubmissionResultWhereUniqueInput!
}

input SubmissionResultUpsertWithWhereUniqueWithoutSubmissionInput {
  create: SubmissionResultCreateWithoutSubmissionInput!
  update: SubmissionResultUpdateWithoutSubmissionInput!
  where: SubmissionResultWhereUniqueInput!
}

input SubmissionResultWhereInput {
  AND: [SubmissionResultWhereInput!]
  NOT: [SubmissionResultWhereInput!]
  OR: [SubmissionResultWhereInput!]
  cpuTime: BigIntFilter
  createTime: DateTimeFilter
  id: IntFilter
  memoryUsage: IntFilter
  problemTestcase: ProblemTestcaseRelationFilter
  problemTestcaseId: IntFilter
  result: EnumResultStatusFilter
  submission: SubmissionRelationFilter
  submissionId: IntFilter
  updateTime: DateTimeFilter
}

input SubmissionResultWhereUniqueInput {
  AND: [SubmissionResultWhereInput!]
  NOT: [SubmissionResultWhereInput!]
  OR: [SubmissionResultWhereInput!]
  cpuTime: BigIntFilter
  createTime: DateTimeFilter
  id: Int
  memoryUsage: IntFilter
  problemTestcase: ProblemTestcaseRelationFilter
  problemTestcaseId: IntFilter
  result: EnumResultStatusFilter
  submission: SubmissionRelationFilter
  submissionId: IntFilter
  updateTime: DateTimeFilter
}

input SubmissionScalarWhereInput {
  AND: [SubmissionScalarWhereInput!]
  NOT: [SubmissionScalarWhereInput!]
  OR: [SubmissionScalarWhereInput!]
  code: JsonNullableListFilter
  codeSize: IntNullableFilter
  contestId: IntNullableFilter
  createTime: DateTimeFilter
  id: IntFilter
  language: EnumLanguageFilter
  problemId: IntFilter
  result: EnumResultStatusFilter
  updateTime: DateTimeFilter
  userId: IntNullableFilter
  workbookId: IntNullableFilter
}

type SubmissionSumAggregate {
  codeSize: Int
  contestId: Int
  id: Int
  problemId: Int
  userId: Int
  workbookId: Int
}

input SubmissionUpdateManyMutationInput {
  code: [JSON!]
  codeSize: Int
  createTime: DateTime
  language: Language
  result: ResultStatus
  updateTime: DateTime
}

input SubmissionUpdateManyWithWhereWithoutContestInput {
  data: SubmissionUpdateManyMutationInput!
  where: SubmissionScalarWhereInput!
}

input SubmissionUpdateManyWithWhereWithoutProblemInput {
  data: SubmissionUpdateManyMutationInput!
  where: SubmissionScalarWhereInput!
}

input SubmissionUpdateManyWithWhereWithoutUserInput {
  data: SubmissionUpdateManyMutationInput!
  where: SubmissionScalarWhereInput!
}

input SubmissionUpdateManyWithWhereWithoutWorkbookInput {
  data: SubmissionUpdateManyMutationInput!
  where: SubmissionScalarWhereInput!
}

input SubmissionUpdateManyWithoutContestNestedInput {
  connect: [SubmissionWhereUniqueInput!]
  connectOrCreate: [SubmissionCreateOrConnectWithoutContestInput!]
  create: [SubmissionCreateWithoutContestInput!]
  createMany: SubmissionCreateManyContestInputEnvelope
  delete: [SubmissionWhereUniqueInput!]
  deleteMany: [SubmissionScalarWhereInput!]
  disconnect: [SubmissionWhereUniqueInput!]
  set: [SubmissionWhereUniqueInput!]
  update: [SubmissionUpdateWithWhereUniqueWithoutContestInput!]
  updateMany: [SubmissionUpdateManyWithWhereWithoutContestInput!]
  upsert: [SubmissionUpsertWithWhereUniqueWithoutContestInput!]
}

input SubmissionUpdateManyWithoutProblemNestedInput {
  connect: [SubmissionWhereUniqueInput!]
  connectOrCreate: [SubmissionCreateOrConnectWithoutProblemInput!]
  create: [SubmissionCreateWithoutProblemInput!]
  createMany: SubmissionCreateManyProblemInputEnvelope
  delete: [SubmissionWhereUniqueInput!]
  deleteMany: [SubmissionScalarWhereInput!]
  disconnect: [SubmissionWhereUniqueInput!]
  set: [SubmissionWhereUniqueInput!]
  update: [SubmissionUpdateWithWhereUniqueWithoutProblemInput!]
  updateMany: [SubmissionUpdateManyWithWhereWithoutProblemInput!]
  upsert: [SubmissionUpsertWithWhereUniqueWithoutProblemInput!]
}

input SubmissionUpdateManyWithoutUserNestedInput {
  connect: [SubmissionWhereUniqueInput!]
  connectOrCreate: [SubmissionCreateOrConnectWithoutUserInput!]
  create: [SubmissionCreateWithoutUserInput!]
  createMany: SubmissionCreateManyUserInputEnvelope
  delete: [SubmissionWhereUniqueInput!]
  deleteMany: [SubmissionScalarWhereInput!]
  disconnect: [SubmissionWhereUniqueInput!]
  set: [SubmissionWhereUniqueInput!]
  update: [SubmissionUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [SubmissionUpdateManyWithWhereWithoutUserInput!]
  upsert: [SubmissionUpsertWithWhereUniqueWithoutUserInput!]
}

input SubmissionUpdateManyWithoutWorkbookNestedInput {
  connect: [SubmissionWhereUniqueInput!]
  connectOrCreate: [SubmissionCreateOrConnectWithoutWorkbookInput!]
  create: [SubmissionCreateWithoutWorkbookInput!]
  createMany: SubmissionCreateManyWorkbookInputEnvelope
  delete: [SubmissionWhereUniqueInput!]
  deleteMany: [SubmissionScalarWhereInput!]
  disconnect: [SubmissionWhereUniqueInput!]
  set: [SubmissionWhereUniqueInput!]
  update: [SubmissionUpdateWithWhereUniqueWithoutWorkbookInput!]
  updateMany: [SubmissionUpdateManyWithWhereWithoutWorkbookInput!]
  upsert: [SubmissionUpsertWithWhereUniqueWithoutWorkbookInput!]
}

input SubmissionUpdateOneRequiredWithoutSubmissionResultNestedInput {
  connect: SubmissionWhereUniqueInput
  connectOrCreate: SubmissionCreateOrConnectWithoutSubmissionResultInput
  create: SubmissionCreateWithoutSubmissionResultInput
  update: SubmissionUpdateToOneWithWhereWithoutSubmissionResultInput
  upsert: SubmissionUpsertWithoutSubmissionResultInput
}

input SubmissionUpdateToOneWithWhereWithoutSubmissionResultInput {
  data: SubmissionUpdateWithoutSubmissionResultInput!
  where: SubmissionWhereInput
}

input SubmissionUpdateWithWhereUniqueWithoutContestInput {
  data: SubmissionUpdateWithoutContestInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionUpdateWithWhereUniqueWithoutProblemInput {
  data: SubmissionUpdateWithoutProblemInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionUpdateWithWhereUniqueWithoutUserInput {
  data: SubmissionUpdateWithoutUserInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionUpdateWithWhereUniqueWithoutWorkbookInput {
  data: SubmissionUpdateWithoutWorkbookInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionUpdateWithoutContestInput {
  code: [JSON!]
  codeSize: Int
  createTime: DateTime
  language: Language
  problem: ProblemUpdateOneRequiredWithoutSubmissionNestedInput
  result: ResultStatus
  submissionResult: SubmissionResultUpdateManyWithoutSubmissionNestedInput
  updateTime: DateTime
  user: UserUpdateOneWithoutSubmissionNestedInput
  workbook: WorkbookUpdateOneWithoutSubmissionNestedInput
}

input SubmissionUpdateWithoutProblemInput {
  code: [JSON!]
  codeSize: Int
  contest: ContestUpdateOneWithoutSubmissionNestedInput
  createTime: DateTime
  language: Language
  result: ResultStatus
  submissionResult: SubmissionResultUpdateManyWithoutSubmissionNestedInput
  updateTime: DateTime
  user: UserUpdateOneWithoutSubmissionNestedInput
  workbook: WorkbookUpdateOneWithoutSubmissionNestedInput
}

input SubmissionUpdateWithoutSubmissionResultInput {
  code: [JSON!]
  codeSize: Int
  contest: ContestUpdateOneWithoutSubmissionNestedInput
  createTime: DateTime
  language: Language
  problem: ProblemUpdateOneRequiredWithoutSubmissionNestedInput
  result: ResultStatus
  updateTime: DateTime
  user: UserUpdateOneWithoutSubmissionNestedInput
  workbook: WorkbookUpdateOneWithoutSubmissionNestedInput
}

input SubmissionUpdateWithoutUserInput {
  code: [JSON!]
  codeSize: Int
  contest: ContestUpdateOneWithoutSubmissionNestedInput
  createTime: DateTime
  language: Language
  problem: ProblemUpdateOneRequiredWithoutSubmissionNestedInput
  result: ResultStatus
  submissionResult: SubmissionResultUpdateManyWithoutSubmissionNestedInput
  updateTime: DateTime
  workbook: WorkbookUpdateOneWithoutSubmissionNestedInput
}

input SubmissionUpdateWithoutWorkbookInput {
  code: [JSON!]
  codeSize: Int
  contest: ContestUpdateOneWithoutSubmissionNestedInput
  createTime: DateTime
  language: Language
  problem: ProblemUpdateOneRequiredWithoutSubmissionNestedInput
  result: ResultStatus
  submissionResult: SubmissionResultUpdateManyWithoutSubmissionNestedInput
  updateTime: DateTime
  user: UserUpdateOneWithoutSubmissionNestedInput
}

input SubmissionUpsertWithWhereUniqueWithoutContestInput {
  create: SubmissionCreateWithoutContestInput!
  update: SubmissionUpdateWithoutContestInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionUpsertWithWhereUniqueWithoutProblemInput {
  create: SubmissionCreateWithoutProblemInput!
  update: SubmissionUpdateWithoutProblemInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionUpsertWithWhereUniqueWithoutUserInput {
  create: SubmissionCreateWithoutUserInput!
  update: SubmissionUpdateWithoutUserInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionUpsertWithWhereUniqueWithoutWorkbookInput {
  create: SubmissionCreateWithoutWorkbookInput!
  update: SubmissionUpdateWithoutWorkbookInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionUpsertWithoutSubmissionResultInput {
  create: SubmissionCreateWithoutSubmissionResultInput!
  update: SubmissionUpdateWithoutSubmissionResultInput!
  where: SubmissionWhereInput
}

input SubmissionWhereInput {
  AND: [SubmissionWhereInput!]
  NOT: [SubmissionWhereInput!]
  OR: [SubmissionWhereInput!]
  code: JsonNullableListFilter
  codeSize: IntNullableFilter
  contest: ContestNullableRelationFilter
  contestId: IntNullableFilter
  createTime: DateTimeFilter
  id: IntFilter
  language: EnumLanguageFilter
  problem: ProblemRelationFilter
  problemId: IntFilter
  result: EnumResultStatusFilter
  submissionResult: SubmissionResultListRelationFilter
  updateTime: DateTimeFilter
  user: UserNullableRelationFilter
  userId: IntNullableFilter
  workbook: WorkbookNullableRelationFilter
  workbookId: IntNullableFilter
}

input SubmissionWhereUniqueInput {
  AND: [SubmissionWhereInput!]
  NOT: [SubmissionWhereInput!]
  OR: [SubmissionWhereInput!]
  code: JsonNullableListFilter
  codeSize: IntNullableFilter
  contest: ContestNullableRelationFilter
  contestId: IntNullableFilter
  createTime: DateTimeFilter
  id: Int
  language: EnumLanguageFilter
  problem: ProblemRelationFilter
  problemId: IntFilter
  result: EnumResultStatusFilter
  submissionResult: SubmissionResultListRelationFilter
  updateTime: DateTimeFilter
  user: UserNullableRelationFilter
  userId: IntNullableFilter
  workbook: WorkbookNullableRelationFilter
  workbookId: IntNullableFilter
}

type Tag {
  _count: TagCount!
  createTime: DateTime!
  id: ID!
  name: String!
  problemTag: [ProblemTag!]
  updateTime: DateTime!
}

type TagAvgAggregate {
  id: Float
}

type TagCount {
  problemTag: Int!
}

type TagCountAggregate {
  _all: Int!
  createTime: Int!
  id: Int!
  name: Int!
  updateTime: Int!
}

input TagCreateNestedOneWithoutProblemTagInput {
  connect: TagWhereUniqueInput
  connectOrCreate: TagCreateOrConnectWithoutProblemTagInput
  create: TagCreateWithoutProblemTagInput
}

input TagCreateOrConnectWithoutProblemTagInput {
  create: TagCreateWithoutProblemTagInput!
  where: TagWhereUniqueInput!
}

input TagCreateWithoutProblemTagInput {
  createTime: DateTime
  name: String!
  updateTime: DateTime
}

type TagMaxAggregate {
  createTime: DateTime
  id: Int
  name: String
  updateTime: DateTime
}

type TagMinAggregate {
  createTime: DateTime
  id: Int
  name: String
  updateTime: DateTime
}

input TagRelationFilter {
  is: TagWhereInput
  isNot: TagWhereInput
}

type TagSumAggregate {
  id: Int
}

input TagUpdateOneRequiredWithoutProblemTagNestedInput {
  connect: TagWhereUniqueInput
  connectOrCreate: TagCreateOrConnectWithoutProblemTagInput
  create: TagCreateWithoutProblemTagInput
  update: TagUpdateToOneWithWhereWithoutProblemTagInput
  upsert: TagUpsertWithoutProblemTagInput
}

input TagUpdateToOneWithWhereWithoutProblemTagInput {
  data: TagUpdateWithoutProblemTagInput!
  where: TagWhereInput
}

input TagUpdateWithoutProblemTagInput {
  createTime: DateTime
  name: String
  updateTime: DateTime
}

input TagUpsertWithoutProblemTagInput {
  create: TagCreateWithoutProblemTagInput!
  update: TagUpdateWithoutProblemTagInput!
  where: TagWhereInput
}

input TagWhereInput {
  AND: [TagWhereInput!]
  NOT: [TagWhereInput!]
  OR: [TagWhereInput!]
  createTime: DateTimeFilter
  id: IntFilter
  name: StringFilter
  problemTag: ProblemTagListRelationFilter
  updateTime: DateTimeFilter
}

input TagWhereUniqueInput {
  AND: [TagWhereInput!]
  NOT: [TagWhereInput!]
  OR: [TagWhereInput!]
  createTime: DateTimeFilter
  id: Int
  name: String
  problemTag: ProblemTagListRelationFilter
  updateTime: DateTimeFilter
}

input Template {
  code: [Snippet!]!
  language: Language!
}

input Testcase {
  input: String!
  output: String!
  scoreWeight: Int
}

input UpdateContestInput {
  config: ContestConfig!
  description: String!
  endTime: DateTime!
  id: Int!
  startTime: DateTime!
  title: String!
}

input UpdateGroupInput {
  config: Config!
  contest: ContestUpdateManyWithoutGroupNestedInput
  createTime: DateTime
  description: String!
  groupName: String!
  notice: NoticeUpdateManyWithoutGroupNestedInput
  problem: ProblemUpdateManyWithoutGroupNestedInput
  updateTime: DateTime
  userGroup: UserGroupUpdateManyWithoutGroupNestedInput
  workbook: WorkbookUpdateManyWithoutGroupNestedInput
}

input UpdateNoticeInput {
  content: String
  isFixed: Boolean
  isVisible: Boolean
  title: String
}

input UpdateProblemInput {
  description: String
  difficulty: Level
  hint: String
  id: Int!
  inputDescription: String
  isVisible: Boolean
  languages: [Language!]
  memoryLimit: Int
  outputDescription: String
  samples: UpdateSamples
  source: String
  tags: UpdateProblemTagInput
  template: [Template!]
  testcases: [Testcase!]
  timeLimit: Int
  title: String
}

input UpdateProblemTagInput {
  create: [Int!]!
  delete: [Int!]!
}

input UpdateSamples {
  create: [Sample!]!
  delete: [Int!]!
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

input UploadFileInput {
  file: Upload!
}

type User {
  CodeDraft: [CodeDraft!]
  _count: UserCount!
  contest: [Contest!]
  contestRecord: [ContestRecord!]
  createTime: DateTime!
  email: String!
  id: ID!
  lastLogin: DateTime
  notice: [Notice!]
  problem: [Problem!]
  role: Role!
  submission: [Submission!]
  updateTime: DateTime!
  userGroup: [UserGroup!]
  userProfile: UserProfile
  username: String!
  useroauth: UserOAuth
  workbook: [Workbook!]
}

type UserAvgAggregate {
  id: Float
}

type UserCount {
  CodeDraft: Int!
  contest: Int!
  contestRecord: Int!
  notice: Int!
  problem: Int!
  submission: Int!
  userGroup: Int!
  workbook: Int!
}

type UserCountAggregate {
  _all: Int!
  createTime: Int!
  email: Int!
  id: Int!
  lastLogin: Int!
  role: Int!
  updateTime: Int!
  username: Int!
}

input UserCreateNestedOneWithoutCodeDraftInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCodeDraftInput
  create: UserCreateWithoutCodeDraftInput
}

input UserCreateNestedOneWithoutContestInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutContestInput
  create: UserCreateWithoutContestInput
}

input UserCreateNestedOneWithoutContestRecordInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutContestRecordInput
  create: UserCreateWithoutContestRecordInput
}

input UserCreateNestedOneWithoutNoticeInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutNoticeInput
  create: UserCreateWithoutNoticeInput
}

input UserCreateNestedOneWithoutProblemInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutProblemInput
  create: UserCreateWithoutProblemInput
}

input UserCreateNestedOneWithoutSubmissionInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSubmissionInput
  create: UserCreateWithoutSubmissionInput
}

input UserCreateNestedOneWithoutUserGroupInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutUserGroupInput
  create: UserCreateWithoutUserGroupInput
}

input UserCreateNestedOneWithoutWorkbookInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutWorkbookInput
  create: UserCreateWithoutWorkbookInput
}

input UserCreateOrConnectWithoutCodeDraftInput {
  create: UserCreateWithoutCodeDraftInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutContestInput {
  create: UserCreateWithoutContestInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutContestRecordInput {
  create: UserCreateWithoutContestRecordInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutNoticeInput {
  create: UserCreateWithoutNoticeInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutProblemInput {
  create: UserCreateWithoutProblemInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutSubmissionInput {
  create: UserCreateWithoutSubmissionInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutUserGroupInput {
  create: UserCreateWithoutUserGroupInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutWorkbookInput {
  create: UserCreateWithoutWorkbookInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutCodeDraftInput {
  contest: ContestCreateNestedManyWithoutCreatedByInput
  contestRecord: ContestRecordCreateNestedManyWithoutUserInput
  createTime: DateTime
  email: String!
  lastLogin: DateTime
  notice: NoticeCreateNestedManyWithoutCreatedByInput
  password: String!
  problem: ProblemCreateNestedManyWithoutCreatedByInput
  role: Role
  submission: SubmissionCreateNestedManyWithoutUserInput
  updateTime: DateTime
  userGroup: UserGroupCreateNestedManyWithoutUserInput
  userProfile: UserProfileCreateNestedOneWithoutUserInput
  username: String!
  useroauth: UserOAuthCreateNestedOneWithoutUserInput
  workbook: WorkbookCreateNestedManyWithoutCreatedByInput
}

input UserCreateWithoutContestInput {
  CodeDraft: CodeDraftCreateNestedManyWithoutUserInput
  contestRecord: ContestRecordCreateNestedManyWithoutUserInput
  createTime: DateTime
  email: String!
  lastLogin: DateTime
  notice: NoticeCreateNestedManyWithoutCreatedByInput
  password: String!
  problem: ProblemCreateNestedManyWithoutCreatedByInput
  role: Role
  submission: SubmissionCreateNestedManyWithoutUserInput
  updateTime: DateTime
  userGroup: UserGroupCreateNestedManyWithoutUserInput
  userProfile: UserProfileCreateNestedOneWithoutUserInput
  username: String!
  useroauth: UserOAuthCreateNestedOneWithoutUserInput
  workbook: WorkbookCreateNestedManyWithoutCreatedByInput
}

input UserCreateWithoutContestRecordInput {
  CodeDraft: CodeDraftCreateNestedManyWithoutUserInput
  contest: ContestCreateNestedManyWithoutCreatedByInput
  createTime: DateTime
  email: String!
  lastLogin: DateTime
  notice: NoticeCreateNestedManyWithoutCreatedByInput
  password: String!
  problem: ProblemCreateNestedManyWithoutCreatedByInput
  role: Role
  submission: SubmissionCreateNestedManyWithoutUserInput
  updateTime: DateTime
  userGroup: UserGroupCreateNestedManyWithoutUserInput
  userProfile: UserProfileCreateNestedOneWithoutUserInput
  username: String!
  useroauth: UserOAuthCreateNestedOneWithoutUserInput
  workbook: WorkbookCreateNestedManyWithoutCreatedByInput
}

input UserCreateWithoutNoticeInput {
  CodeDraft: CodeDraftCreateNestedManyWithoutUserInput
  contest: ContestCreateNestedManyWithoutCreatedByInput
  contestRecord: ContestRecordCreateNestedManyWithoutUserInput
  createTime: DateTime
  email: String!
  lastLogin: DateTime
  password: String!
  problem: ProblemCreateNestedManyWithoutCreatedByInput
  role: Role
  submission: SubmissionCreateNestedManyWithoutUserInput
  updateTime: DateTime
  userGroup: UserGroupCreateNestedManyWithoutUserInput
  userProfile: UserProfileCreateNestedOneWithoutUserInput
  username: String!
  useroauth: UserOAuthCreateNestedOneWithoutUserInput
  workbook: WorkbookCreateNestedManyWithoutCreatedByInput
}

input UserCreateWithoutProblemInput {
  CodeDraft: CodeDraftCreateNestedManyWithoutUserInput
  contest: ContestCreateNestedManyWithoutCreatedByInput
  contestRecord: ContestRecordCreateNestedManyWithoutUserInput
  createTime: DateTime
  email: String!
  lastLogin: DateTime
  notice: NoticeCreateNestedManyWithoutCreatedByInput
  password: String!
  role: Role
  submission: SubmissionCreateNestedManyWithoutUserInput
  updateTime: DateTime
  userGroup: UserGroupCreateNestedManyWithoutUserInput
  userProfile: UserProfileCreateNestedOneWithoutUserInput
  username: String!
  useroauth: UserOAuthCreateNestedOneWithoutUserInput
  workbook: WorkbookCreateNestedManyWithoutCreatedByInput
}

input UserCreateWithoutSubmissionInput {
  CodeDraft: CodeDraftCreateNestedManyWithoutUserInput
  contest: ContestCreateNestedManyWithoutCreatedByInput
  contestRecord: ContestRecordCreateNestedManyWithoutUserInput
  createTime: DateTime
  email: String!
  lastLogin: DateTime
  notice: NoticeCreateNestedManyWithoutCreatedByInput
  password: String!
  problem: ProblemCreateNestedManyWithoutCreatedByInput
  role: Role
  updateTime: DateTime
  userGroup: UserGroupCreateNestedManyWithoutUserInput
  userProfile: UserProfileCreateNestedOneWithoutUserInput
  username: String!
  useroauth: UserOAuthCreateNestedOneWithoutUserInput
  workbook: WorkbookCreateNestedManyWithoutCreatedByInput
}

input UserCreateWithoutUserGroupInput {
  CodeDraft: CodeDraftCreateNestedManyWithoutUserInput
  contest: ContestCreateNestedManyWithoutCreatedByInput
  contestRecord: ContestRecordCreateNestedManyWithoutUserInput
  createTime: DateTime
  email: String!
  lastLogin: DateTime
  notice: NoticeCreateNestedManyWithoutCreatedByInput
  password: String!
  problem: ProblemCreateNestedManyWithoutCreatedByInput
  role: Role
  submission: SubmissionCreateNestedManyWithoutUserInput
  updateTime: DateTime
  userProfile: UserProfileCreateNestedOneWithoutUserInput
  username: String!
  useroauth: UserOAuthCreateNestedOneWithoutUserInput
  workbook: WorkbookCreateNestedManyWithoutCreatedByInput
}

input UserCreateWithoutWorkbookInput {
  CodeDraft: CodeDraftCreateNestedManyWithoutUserInput
  contest: ContestCreateNestedManyWithoutCreatedByInput
  contestRecord: ContestRecordCreateNestedManyWithoutUserInput
  createTime: DateTime
  email: String!
  lastLogin: DateTime
  notice: NoticeCreateNestedManyWithoutCreatedByInput
  password: String!
  problem: ProblemCreateNestedManyWithoutCreatedByInput
  role: Role
  submission: SubmissionCreateNestedManyWithoutUserInput
  updateTime: DateTime
  userGroup: UserGroupCreateNestedManyWithoutUserInput
  userProfile: UserProfileCreateNestedOneWithoutUserInput
  username: String!
  useroauth: UserOAuthCreateNestedOneWithoutUserInput
}

type UserGroup {
  createTime: DateTime!
  group: Group!
  groupId: Int!
  isGroupLeader: Boolean!
  updateTime: DateTime!
  user: User!
  userId: Int!
}

type UserGroupAvgAggregate {
  groupId: Float
  userId: Float
}

type UserGroupCountAggregate {
  _all: Int!
  createTime: Int!
  groupId: Int!
  isGroupLeader: Int!
  updateTime: Int!
  userId: Int!
}

input UserGroupCreateManyGroupInput {
  createTime: DateTime
  isGroupLeader: Boolean
  updateTime: DateTime
  userId: Int!
}

input UserGroupCreateManyGroupInputEnvelope {
  data: [UserGroupCreateManyGroupInput!]!
  skipDuplicates: Boolean
}

input UserGroupCreateManyUserInput {
  createTime: DateTime
  groupId: Int!
  isGroupLeader: Boolean
  updateTime: DateTime
}

input UserGroupCreateManyUserInputEnvelope {
  data: [UserGroupCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input UserGroupCreateNestedManyWithoutGroupInput {
  connect: [UserGroupWhereUniqueInput!]
  connectOrCreate: [UserGroupCreateOrConnectWithoutGroupInput!]
  create: [UserGroupCreateWithoutGroupInput!]
  createMany: UserGroupCreateManyGroupInputEnvelope
}

input UserGroupCreateNestedManyWithoutUserInput {
  connect: [UserGroupWhereUniqueInput!]
  connectOrCreate: [UserGroupCreateOrConnectWithoutUserInput!]
  create: [UserGroupCreateWithoutUserInput!]
  createMany: UserGroupCreateManyUserInputEnvelope
}

input UserGroupCreateOrConnectWithoutGroupInput {
  create: UserGroupCreateWithoutGroupInput!
  where: UserGroupWhereUniqueInput!
}

input UserGroupCreateOrConnectWithoutUserInput {
  create: UserGroupCreateWithoutUserInput!
  where: UserGroupWhereUniqueInput!
}

input UserGroupCreateWithoutGroupInput {
  createTime: DateTime
  isGroupLeader: Boolean
  updateTime: DateTime
  user: UserCreateNestedOneWithoutUserGroupInput!
}

input UserGroupCreateWithoutUserInput {
  createTime: DateTime
  group: GroupCreateNestedOneWithoutUserGroupInput!
  isGroupLeader: Boolean
  updateTime: DateTime
}

input UserGroupListRelationFilter {
  every: UserGroupWhereInput
  none: UserGroupWhereInput
  some: UserGroupWhereInput
}

type UserGroupMaxAggregate {
  createTime: DateTime
  groupId: Int
  isGroupLeader: Boolean
  updateTime: DateTime
  userId: Int
}

type UserGroupMinAggregate {
  createTime: DateTime
  groupId: Int
  isGroupLeader: Boolean
  updateTime: DateTime
  userId: Int
}

input UserGroupScalarWhereInput {
  AND: [UserGroupScalarWhereInput!]
  NOT: [UserGroupScalarWhereInput!]
  OR: [UserGroupScalarWhereInput!]
  createTime: DateTimeFilter
  groupId: IntFilter
  isGroupLeader: BoolFilter
  updateTime: DateTimeFilter
  userId: IntFilter
}

type UserGroupSumAggregate {
  groupId: Int
  userId: Int
}

input UserGroupUpdateManyMutationInput {
  createTime: DateTime
  isGroupLeader: Boolean
  updateTime: DateTime
}

input UserGroupUpdateManyWithWhereWithoutGroupInput {
  data: UserGroupUpdateManyMutationInput!
  where: UserGroupScalarWhereInput!
}

input UserGroupUpdateManyWithWhereWithoutUserInput {
  data: UserGroupUpdateManyMutationInput!
  where: UserGroupScalarWhereInput!
}

input UserGroupUpdateManyWithoutGroupNestedInput {
  connect: [UserGroupWhereUniqueInput!]
  connectOrCreate: [UserGroupCreateOrConnectWithoutGroupInput!]
  create: [UserGroupCreateWithoutGroupInput!]
  createMany: UserGroupCreateManyGroupInputEnvelope
  delete: [UserGroupWhereUniqueInput!]
  deleteMany: [UserGroupScalarWhereInput!]
  disconnect: [UserGroupWhereUniqueInput!]
  set: [UserGroupWhereUniqueInput!]
  update: [UserGroupUpdateWithWhereUniqueWithoutGroupInput!]
  updateMany: [UserGroupUpdateManyWithWhereWithoutGroupInput!]
  upsert: [UserGroupUpsertWithWhereUniqueWithoutGroupInput!]
}

input UserGroupUpdateManyWithoutUserNestedInput {
  connect: [UserGroupWhereUniqueInput!]
  connectOrCreate: [UserGroupCreateOrConnectWithoutUserInput!]
  create: [UserGroupCreateWithoutUserInput!]
  createMany: UserGroupCreateManyUserInputEnvelope
  delete: [UserGroupWhereUniqueInput!]
  deleteMany: [UserGroupScalarWhereInput!]
  disconnect: [UserGroupWhereUniqueInput!]
  set: [UserGroupWhereUniqueInput!]
  update: [UserGroupUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [UserGroupUpdateManyWithWhereWithoutUserInput!]
  upsert: [UserGroupUpsertWithWhereUniqueWithoutUserInput!]
}

input UserGroupUpdateWithWhereUniqueWithoutGroupInput {
  data: UserGroupUpdateWithoutGroupInput!
  where: UserGroupWhereUniqueInput!
}

input UserGroupUpdateWithWhereUniqueWithoutUserInput {
  data: UserGroupUpdateWithoutUserInput!
  where: UserGroupWhereUniqueInput!
}

input UserGroupUpdateWithoutGroupInput {
  createTime: DateTime
  isGroupLeader: Boolean
  updateTime: DateTime
  user: UserUpdateOneRequiredWithoutUserGroupNestedInput
}

input UserGroupUpdateWithoutUserInput {
  createTime: DateTime
  group: GroupUpdateOneRequiredWithoutUserGroupNestedInput
  isGroupLeader: Boolean
  updateTime: DateTime
}

input UserGroupUpsertWithWhereUniqueWithoutGroupInput {
  create: UserGroupCreateWithoutGroupInput!
  update: UserGroupUpdateWithoutGroupInput!
  where: UserGroupWhereUniqueInput!
}

input UserGroupUpsertWithWhereUniqueWithoutUserInput {
  create: UserGroupCreateWithoutUserInput!
  update: UserGroupUpdateWithoutUserInput!
  where: UserGroupWhereUniqueInput!
}

input UserGroupUserIdGroupIdCompoundUniqueInput {
  groupId: Int!
  userId: Int!
}

input UserGroupWhereInput {
  AND: [UserGroupWhereInput!]
  NOT: [UserGroupWhereInput!]
  OR: [UserGroupWhereInput!]
  createTime: DateTimeFilter
  group: GroupRelationFilter
  groupId: IntFilter
  isGroupLeader: BoolFilter
  updateTime: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

input UserGroupWhereUniqueInput {
  AND: [UserGroupWhereInput!]
  NOT: [UserGroupWhereInput!]
  OR: [UserGroupWhereInput!]
  createTime: DateTimeFilter
  group: GroupRelationFilter
  groupId: IntFilter
  isGroupLeader: BoolFilter
  updateTime: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
  userId_groupId: UserGroupUserIdGroupIdCompoundUniqueInput
}

type UserMaxAggregate {
  createTime: DateTime
  email: String
  id: Int
  lastLogin: DateTime
  role: Role
  updateTime: DateTime
  username: String
}

type UserMinAggregate {
  createTime: DateTime
  email: String
  id: Int
  lastLogin: DateTime
  role: Role
  updateTime: DateTime
  username: String
}

input UserNullableRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

type UserOAuth {
  createTime: DateTime!
  id: String!
  provider: Provider!
  updateTime: DateTime!
  user: User!
  userId: Int!
}

type UserOAuthAvgAggregate {
  userId: Float
}

type UserOAuthCountAggregate {
  _all: Int!
  createTime: Int!
  id: Int!
  provider: Int!
  updateTime: Int!
  userId: Int!
}

input UserOAuthCreateNestedOneWithoutUserInput {
  connect: UserOAuthWhereUniqueInput
  connectOrCreate: UserOAuthCreateOrConnectWithoutUserInput
  create: UserOAuthCreateWithoutUserInput
}

input UserOAuthCreateOrConnectWithoutUserInput {
  create: UserOAuthCreateWithoutUserInput!
  where: UserOAuthWhereUniqueInput!
}

input UserOAuthCreateWithoutUserInput {
  createTime: DateTime
  id: String!
  provider: Provider!
  updateTime: DateTime
}

input UserOAuthIdProviderCompoundUniqueInput {
  id: String!
  provider: Provider!
}

type UserOAuthMaxAggregate {
  createTime: DateTime
  id: String
  provider: Provider
  updateTime: DateTime
  userId: Int
}

type UserOAuthMinAggregate {
  createTime: DateTime
  id: String
  provider: Provider
  updateTime: DateTime
  userId: Int
}

input UserOAuthNullableRelationFilter {
  is: UserOAuthWhereInput
  isNot: UserOAuthWhereInput
}

type UserOAuthSumAggregate {
  userId: Int
}

input UserOAuthUpdateOneWithoutUserNestedInput {
  connect: UserOAuthWhereUniqueInput
  connectOrCreate: UserOAuthCreateOrConnectWithoutUserInput
  create: UserOAuthCreateWithoutUserInput
  delete: UserOAuthWhereInput
  disconnect: UserOAuthWhereInput
  update: UserOAuthUpdateToOneWithWhereWithoutUserInput
  upsert: UserOAuthUpsertWithoutUserInput
}

input UserOAuthUpdateToOneWithWhereWithoutUserInput {
  data: UserOAuthUpdateWithoutUserInput!
  where: UserOAuthWhereInput
}

input UserOAuthUpdateWithoutUserInput {
  createTime: DateTime
  id: String
  provider: Provider
  updateTime: DateTime
}

input UserOAuthUpsertWithoutUserInput {
  create: UserOAuthCreateWithoutUserInput!
  update: UserOAuthUpdateWithoutUserInput!
  where: UserOAuthWhereInput
}

input UserOAuthWhereInput {
  AND: [UserOAuthWhereInput!]
  NOT: [UserOAuthWhereInput!]
  OR: [UserOAuthWhereInput!]
  createTime: DateTimeFilter
  id: StringFilter
  provider: EnumProviderFilter
  updateTime: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

input UserOAuthWhereUniqueInput {
  AND: [UserOAuthWhereInput!]
  NOT: [UserOAuthWhereInput!]
  OR: [UserOAuthWhereInput!]
  createTime: DateTimeFilter
  id: StringFilter
  id_provider: UserOAuthIdProviderCompoundUniqueInput
  provider: EnumProviderFilter
  updateTime: DateTimeFilter
  user: UserRelationFilter
  userId: Int
}

type UserProfile {
  createTime: DateTime!
  id: ID!
  realName: String!
  updateTime: DateTime!
  user: User!
  userId: Int!
}

type UserProfileAvgAggregate {
  id: Float
  userId: Float
}

type UserProfileCountAggregate {
  _all: Int!
  createTime: Int!
  id: Int!
  realName: Int!
  updateTime: Int!
  userId: Int!
}

input UserProfileCreateNestedOneWithoutUserInput {
  connect: UserProfileWhereUniqueInput
  connectOrCreate: UserProfileCreateOrConnectWithoutUserInput
  create: UserProfileCreateWithoutUserInput
}

input UserProfileCreateOrConnectWithoutUserInput {
  create: UserProfileCreateWithoutUserInput!
  where: UserProfileWhereUniqueInput!
}

input UserProfileCreateWithoutUserInput {
  createTime: DateTime
  realName: String!
  updateTime: DateTime
}

type UserProfileMaxAggregate {
  createTime: DateTime
  id: Int
  realName: String
  updateTime: DateTime
  userId: Int
}

type UserProfileMinAggregate {
  createTime: DateTime
  id: Int
  realName: String
  updateTime: DateTime
  userId: Int
}

input UserProfileNullableRelationFilter {
  is: UserProfileWhereInput
  isNot: UserProfileWhereInput
}

type UserProfileSumAggregate {
  id: Int
  userId: Int
}

input UserProfileUpdateOneWithoutUserNestedInput {
  connect: UserProfileWhereUniqueInput
  connectOrCreate: UserProfileCreateOrConnectWithoutUserInput
  create: UserProfileCreateWithoutUserInput
  delete: UserProfileWhereInput
  disconnect: UserProfileWhereInput
  update: UserProfileUpdateToOneWithWhereWithoutUserInput
  upsert: UserProfileUpsertWithoutUserInput
}

input UserProfileUpdateToOneWithWhereWithoutUserInput {
  data: UserProfileUpdateWithoutUserInput!
  where: UserProfileWhereInput
}

input UserProfileUpdateWithoutUserInput {
  createTime: DateTime
  realName: String
  updateTime: DateTime
}

input UserProfileUpsertWithoutUserInput {
  create: UserProfileCreateWithoutUserInput!
  update: UserProfileUpdateWithoutUserInput!
  where: UserProfileWhereInput
}

input UserProfileWhereInput {
  AND: [UserProfileWhereInput!]
  NOT: [UserProfileWhereInput!]
  OR: [UserProfileWhereInput!]
  createTime: DateTimeFilter
  id: IntFilter
  realName: StringFilter
  updateTime: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

input UserProfileWhereUniqueInput {
  AND: [UserProfileWhereInput!]
  NOT: [UserProfileWhereInput!]
  OR: [UserProfileWhereInput!]
  createTime: DateTimeFilter
  id: Int
  realName: StringFilter
  updateTime: DateTimeFilter
  user: UserRelationFilter
  userId: Int
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

type UserSumAggregate {
  id: Int
}

input UserUpdateOneRequiredWithoutCodeDraftNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCodeDraftInput
  create: UserCreateWithoutCodeDraftInput
  update: UserUpdateToOneWithWhereWithoutCodeDraftInput
  upsert: UserUpsertWithoutCodeDraftInput
}

input UserUpdateOneRequiredWithoutUserGroupNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutUserGroupInput
  create: UserCreateWithoutUserGroupInput
  update: UserUpdateToOneWithWhereWithoutUserGroupInput
  upsert: UserUpsertWithoutUserGroupInput
}

input UserUpdateOneWithoutContestNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutContestInput
  create: UserCreateWithoutContestInput
  delete: UserWhereInput
  disconnect: UserWhereInput
  update: UserUpdateToOneWithWhereWithoutContestInput
  upsert: UserUpsertWithoutContestInput
}

input UserUpdateOneWithoutContestRecordNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutContestRecordInput
  create: UserCreateWithoutContestRecordInput
  delete: UserWhereInput
  disconnect: UserWhereInput
  update: UserUpdateToOneWithWhereWithoutContestRecordInput
  upsert: UserUpsertWithoutContestRecordInput
}

input UserUpdateOneWithoutNoticeNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutNoticeInput
  create: UserCreateWithoutNoticeInput
  delete: UserWhereInput
  disconnect: UserWhereInput
  update: UserUpdateToOneWithWhereWithoutNoticeInput
  upsert: UserUpsertWithoutNoticeInput
}

input UserUpdateOneWithoutProblemNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutProblemInput
  create: UserCreateWithoutProblemInput
  delete: UserWhereInput
  disconnect: UserWhereInput
  update: UserUpdateToOneWithWhereWithoutProblemInput
  upsert: UserUpsertWithoutProblemInput
}

input UserUpdateOneWithoutSubmissionNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSubmissionInput
  create: UserCreateWithoutSubmissionInput
  delete: UserWhereInput
  disconnect: UserWhereInput
  update: UserUpdateToOneWithWhereWithoutSubmissionInput
  upsert: UserUpsertWithoutSubmissionInput
}

input UserUpdateOneWithoutWorkbookNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutWorkbookInput
  create: UserCreateWithoutWorkbookInput
  delete: UserWhereInput
  disconnect: UserWhereInput
  update: UserUpdateToOneWithWhereWithoutWorkbookInput
  upsert: UserUpsertWithoutWorkbookInput
}

input UserUpdateToOneWithWhereWithoutCodeDraftInput {
  data: UserUpdateWithoutCodeDraftInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutContestInput {
  data: UserUpdateWithoutContestInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutContestRecordInput {
  data: UserUpdateWithoutContestRecordInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutNoticeInput {
  data: UserUpdateWithoutNoticeInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutProblemInput {
  data: UserUpdateWithoutProblemInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutSubmissionInput {
  data: UserUpdateWithoutSubmissionInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutUserGroupInput {
  data: UserUpdateWithoutUserGroupInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutWorkbookInput {
  data: UserUpdateWithoutWorkbookInput!
  where: UserWhereInput
}

input UserUpdateWithoutCodeDraftInput {
  contest: ContestUpdateManyWithoutCreatedByNestedInput
  contestRecord: ContestRecordUpdateManyWithoutUserNestedInput
  createTime: DateTime
  email: String
  lastLogin: DateTime
  notice: NoticeUpdateManyWithoutCreatedByNestedInput
  password: String
  problem: ProblemUpdateManyWithoutCreatedByNestedInput
  role: Role
  submission: SubmissionUpdateManyWithoutUserNestedInput
  updateTime: DateTime
  userGroup: UserGroupUpdateManyWithoutUserNestedInput
  userProfile: UserProfileUpdateOneWithoutUserNestedInput
  username: String
  useroauth: UserOAuthUpdateOneWithoutUserNestedInput
  workbook: WorkbookUpdateManyWithoutCreatedByNestedInput
}

input UserUpdateWithoutContestInput {
  CodeDraft: CodeDraftUpdateManyWithoutUserNestedInput
  contestRecord: ContestRecordUpdateManyWithoutUserNestedInput
  createTime: DateTime
  email: String
  lastLogin: DateTime
  notice: NoticeUpdateManyWithoutCreatedByNestedInput
  password: String
  problem: ProblemUpdateManyWithoutCreatedByNestedInput
  role: Role
  submission: SubmissionUpdateManyWithoutUserNestedInput
  updateTime: DateTime
  userGroup: UserGroupUpdateManyWithoutUserNestedInput
  userProfile: UserProfileUpdateOneWithoutUserNestedInput
  username: String
  useroauth: UserOAuthUpdateOneWithoutUserNestedInput
  workbook: WorkbookUpdateManyWithoutCreatedByNestedInput
}

input UserUpdateWithoutContestRecordInput {
  CodeDraft: CodeDraftUpdateManyWithoutUserNestedInput
  contest: ContestUpdateManyWithoutCreatedByNestedInput
  createTime: DateTime
  email: String
  lastLogin: DateTime
  notice: NoticeUpdateManyWithoutCreatedByNestedInput
  password: String
  problem: ProblemUpdateManyWithoutCreatedByNestedInput
  role: Role
  submission: SubmissionUpdateManyWithoutUserNestedInput
  updateTime: DateTime
  userGroup: UserGroupUpdateManyWithoutUserNestedInput
  userProfile: UserProfileUpdateOneWithoutUserNestedInput
  username: String
  useroauth: UserOAuthUpdateOneWithoutUserNestedInput
  workbook: WorkbookUpdateManyWithoutCreatedByNestedInput
}

input UserUpdateWithoutNoticeInput {
  CodeDraft: CodeDraftUpdateManyWithoutUserNestedInput
  contest: ContestUpdateManyWithoutCreatedByNestedInput
  contestRecord: ContestRecordUpdateManyWithoutUserNestedInput
  createTime: DateTime
  email: String
  lastLogin: DateTime
  password: String
  problem: ProblemUpdateManyWithoutCreatedByNestedInput
  role: Role
  submission: SubmissionUpdateManyWithoutUserNestedInput
  updateTime: DateTime
  userGroup: UserGroupUpdateManyWithoutUserNestedInput
  userProfile: UserProfileUpdateOneWithoutUserNestedInput
  username: String
  useroauth: UserOAuthUpdateOneWithoutUserNestedInput
  workbook: WorkbookUpdateManyWithoutCreatedByNestedInput
}

input UserUpdateWithoutProblemInput {
  CodeDraft: CodeDraftUpdateManyWithoutUserNestedInput
  contest: ContestUpdateManyWithoutCreatedByNestedInput
  contestRecord: ContestRecordUpdateManyWithoutUserNestedInput
  createTime: DateTime
  email: String
  lastLogin: DateTime
  notice: NoticeUpdateManyWithoutCreatedByNestedInput
  password: String
  role: Role
  submission: SubmissionUpdateManyWithoutUserNestedInput
  updateTime: DateTime
  userGroup: UserGroupUpdateManyWithoutUserNestedInput
  userProfile: UserProfileUpdateOneWithoutUserNestedInput
  username: String
  useroauth: UserOAuthUpdateOneWithoutUserNestedInput
  workbook: WorkbookUpdateManyWithoutCreatedByNestedInput
}

input UserUpdateWithoutSubmissionInput {
  CodeDraft: CodeDraftUpdateManyWithoutUserNestedInput
  contest: ContestUpdateManyWithoutCreatedByNestedInput
  contestRecord: ContestRecordUpdateManyWithoutUserNestedInput
  createTime: DateTime
  email: String
  lastLogin: DateTime
  notice: NoticeUpdateManyWithoutCreatedByNestedInput
  password: String
  problem: ProblemUpdateManyWithoutCreatedByNestedInput
  role: Role
  updateTime: DateTime
  userGroup: UserGroupUpdateManyWithoutUserNestedInput
  userProfile: UserProfileUpdateOneWithoutUserNestedInput
  username: String
  useroauth: UserOAuthUpdateOneWithoutUserNestedInput
  workbook: WorkbookUpdateManyWithoutCreatedByNestedInput
}

input UserUpdateWithoutUserGroupInput {
  CodeDraft: CodeDraftUpdateManyWithoutUserNestedInput
  contest: ContestUpdateManyWithoutCreatedByNestedInput
  contestRecord: ContestRecordUpdateManyWithoutUserNestedInput
  createTime: DateTime
  email: String
  lastLogin: DateTime
  notice: NoticeUpdateManyWithoutCreatedByNestedInput
  password: String
  problem: ProblemUpdateManyWithoutCreatedByNestedInput
  role: Role
  submission: SubmissionUpdateManyWithoutUserNestedInput
  updateTime: DateTime
  userProfile: UserProfileUpdateOneWithoutUserNestedInput
  username: String
  useroauth: UserOAuthUpdateOneWithoutUserNestedInput
  workbook: WorkbookUpdateManyWithoutCreatedByNestedInput
}

input UserUpdateWithoutWorkbookInput {
  CodeDraft: CodeDraftUpdateManyWithoutUserNestedInput
  contest: ContestUpdateManyWithoutCreatedByNestedInput
  contestRecord: ContestRecordUpdateManyWithoutUserNestedInput
  createTime: DateTime
  email: String
  lastLogin: DateTime
  notice: NoticeUpdateManyWithoutCreatedByNestedInput
  password: String
  problem: ProblemUpdateManyWithoutCreatedByNestedInput
  role: Role
  submission: SubmissionUpdateManyWithoutUserNestedInput
  updateTime: DateTime
  userGroup: UserGroupUpdateManyWithoutUserNestedInput
  userProfile: UserProfileUpdateOneWithoutUserNestedInput
  username: String
  useroauth: UserOAuthUpdateOneWithoutUserNestedInput
}

input UserUpsertWithoutCodeDraftInput {
  create: UserCreateWithoutCodeDraftInput!
  update: UserUpdateWithoutCodeDraftInput!
  where: UserWhereInput
}

input UserUpsertWithoutContestInput {
  create: UserCreateWithoutContestInput!
  update: UserUpdateWithoutContestInput!
  where: UserWhereInput
}

input UserUpsertWithoutContestRecordInput {
  create: UserCreateWithoutContestRecordInput!
  update: UserUpdateWithoutContestRecordInput!
  where: UserWhereInput
}

input UserUpsertWithoutNoticeInput {
  create: UserCreateWithoutNoticeInput!
  update: UserUpdateWithoutNoticeInput!
  where: UserWhereInput
}

input UserUpsertWithoutProblemInput {
  create: UserCreateWithoutProblemInput!
  update: UserUpdateWithoutProblemInput!
  where: UserWhereInput
}

input UserUpsertWithoutSubmissionInput {
  create: UserCreateWithoutSubmissionInput!
  update: UserUpdateWithoutSubmissionInput!
  where: UserWhereInput
}

input UserUpsertWithoutUserGroupInput {
  create: UserCreateWithoutUserGroupInput!
  update: UserUpdateWithoutUserGroupInput!
  where: UserWhereInput
}

input UserUpsertWithoutWorkbookInput {
  create: UserCreateWithoutWorkbookInput!
  update: UserUpdateWithoutWorkbookInput!
  where: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  CodeDraft: CodeDraftListRelationFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  contest: ContestListRelationFilter
  contestRecord: ContestRecordListRelationFilter
  createTime: DateTimeFilter
  email: StringFilter
  id: IntFilter
  lastLogin: DateTimeNullableFilter
  notice: NoticeListRelationFilter
  password: StringFilter
  problem: ProblemListRelationFilter
  role: EnumRoleFilter
  submission: SubmissionListRelationFilter
  updateTime: DateTimeFilter
  userGroup: UserGroupListRelationFilter
  userProfile: UserProfileNullableRelationFilter
  username: StringFilter
  useroauth: UserOAuthNullableRelationFilter
  workbook: WorkbookListRelationFilter
}

input UserWhereUniqueInput {
  AND: [UserWhereInput!]
  CodeDraft: CodeDraftListRelationFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  contest: ContestListRelationFilter
  contestRecord: ContestRecordListRelationFilter
  createTime: DateTimeFilter
  email: String
  id: Int
  lastLogin: DateTimeNullableFilter
  notice: NoticeListRelationFilter
  password: StringFilter
  problem: ProblemListRelationFilter
  role: EnumRoleFilter
  submission: SubmissionListRelationFilter
  updateTime: DateTimeFilter
  userGroup: UserGroupListRelationFilter
  userProfile: UserProfileNullableRelationFilter
  username: String
  useroauth: UserOAuthNullableRelationFilter
  workbook: WorkbookListRelationFilter
}

type Workbook {
  _count: WorkbookCount!
  createTime: DateTime!
  createdBy: User
  createdById: Int
  description: String!
  group: Group!
  groupId: Int!
  id: ID!
  isVisible: Boolean!
  submission: [Submission!]
  title: String!
  updateTime: DateTime!
  workbookProblem: [WorkbookProblem!]
}

type WorkbookAvgAggregate {
  createdById: Float
  groupId: Float
  id: Float
}

type WorkbookCount {
  submission: Int!
  workbookProblem: Int!
}

type WorkbookCountAggregate {
  _all: Int!
  createTime: Int!
  createdById: Int!
  description: Int!
  groupId: Int!
  id: Int!
  isVisible: Int!
  title: Int!
  updateTime: Int!
}

input WorkbookCreateManyCreatedByInput {
  createTime: DateTime
  description: String!
  groupId: Int!
  id: Int
  isVisible: Boolean
  title: String!
  updateTime: DateTime
}

input WorkbookCreateManyCreatedByInputEnvelope {
  data: [WorkbookCreateManyCreatedByInput!]!
  skipDuplicates: Boolean
}

input WorkbookCreateManyGroupInput {
  createTime: DateTime
  createdById: Int
  description: String!
  id: Int
  isVisible: Boolean
  title: String!
  updateTime: DateTime
}

input WorkbookCreateManyGroupInputEnvelope {
  data: [WorkbookCreateManyGroupInput!]!
  skipDuplicates: Boolean
}

input WorkbookCreateNestedManyWithoutCreatedByInput {
  connect: [WorkbookWhereUniqueInput!]
  connectOrCreate: [WorkbookCreateOrConnectWithoutCreatedByInput!]
  create: [WorkbookCreateWithoutCreatedByInput!]
  createMany: WorkbookCreateManyCreatedByInputEnvelope
}

input WorkbookCreateNestedManyWithoutGroupInput {
  connect: [WorkbookWhereUniqueInput!]
  connectOrCreate: [WorkbookCreateOrConnectWithoutGroupInput!]
  create: [WorkbookCreateWithoutGroupInput!]
  createMany: WorkbookCreateManyGroupInputEnvelope
}

input WorkbookCreateNestedOneWithoutSubmissionInput {
  connect: WorkbookWhereUniqueInput
  connectOrCreate: WorkbookCreateOrConnectWithoutSubmissionInput
  create: WorkbookCreateWithoutSubmissionInput
}

input WorkbookCreateNestedOneWithoutWorkbookProblemInput {
  connect: WorkbookWhereUniqueInput
  connectOrCreate: WorkbookCreateOrConnectWithoutWorkbookProblemInput
  create: WorkbookCreateWithoutWorkbookProblemInput
}

input WorkbookCreateOrConnectWithoutCreatedByInput {
  create: WorkbookCreateWithoutCreatedByInput!
  where: WorkbookWhereUniqueInput!
}

input WorkbookCreateOrConnectWithoutGroupInput {
  create: WorkbookCreateWithoutGroupInput!
  where: WorkbookWhereUniqueInput!
}

input WorkbookCreateOrConnectWithoutSubmissionInput {
  create: WorkbookCreateWithoutSubmissionInput!
  where: WorkbookWhereUniqueInput!
}

input WorkbookCreateOrConnectWithoutWorkbookProblemInput {
  create: WorkbookCreateWithoutWorkbookProblemInput!
  where: WorkbookWhereUniqueInput!
}

input WorkbookCreateWithoutCreatedByInput {
  createTime: DateTime
  description: String!
  group: GroupCreateNestedOneWithoutWorkbookInput!
  isVisible: Boolean
  submission: SubmissionCreateNestedManyWithoutWorkbookInput
  title: String!
  updateTime: DateTime
  workbookProblem: WorkbookProblemCreateNestedManyWithoutWorkbookInput
}

input WorkbookCreateWithoutGroupInput {
  createTime: DateTime
  createdBy: UserCreateNestedOneWithoutWorkbookInput
  description: String!
  isVisible: Boolean
  submission: SubmissionCreateNestedManyWithoutWorkbookInput
  title: String!
  updateTime: DateTime
  workbookProblem: WorkbookProblemCreateNestedManyWithoutWorkbookInput
}

input WorkbookCreateWithoutSubmissionInput {
  createTime: DateTime
  createdBy: UserCreateNestedOneWithoutWorkbookInput
  description: String!
  group: GroupCreateNestedOneWithoutWorkbookInput!
  isVisible: Boolean
  title: String!
  updateTime: DateTime
  workbookProblem: WorkbookProblemCreateNestedManyWithoutWorkbookInput
}

input WorkbookCreateWithoutWorkbookProblemInput {
  createTime: DateTime
  createdBy: UserCreateNestedOneWithoutWorkbookInput
  description: String!
  group: GroupCreateNestedOneWithoutWorkbookInput!
  isVisible: Boolean
  submission: SubmissionCreateNestedManyWithoutWorkbookInput
  title: String!
  updateTime: DateTime
}

input WorkbookListRelationFilter {
  every: WorkbookWhereInput
  none: WorkbookWhereInput
  some: WorkbookWhereInput
}

type WorkbookMaxAggregate {
  createTime: DateTime
  createdById: Int
  description: String
  groupId: Int
  id: Int
  isVisible: Boolean
  title: String
  updateTime: DateTime
}

type WorkbookMinAggregate {
  createTime: DateTime
  createdById: Int
  description: String
  groupId: Int
  id: Int
  isVisible: Boolean
  title: String
  updateTime: DateTime
}

input WorkbookNullableRelationFilter {
  is: WorkbookWhereInput
  isNot: WorkbookWhereInput
}

type WorkbookProblem {
  createTime: DateTime!
  order: Int!
  problem: Problem!
  problemId: Int!
  updateTime: DateTime!
  workbook: Workbook!
  workbookId: Int!
}

type WorkbookProblemAvgAggregate {
  order: Float
  problemId: Float
  workbookId: Float
}

type WorkbookProblemCountAggregate {
  _all: Int!
  createTime: Int!
  order: Int!
  problemId: Int!
  updateTime: Int!
  workbookId: Int!
}

input WorkbookProblemCreateManyProblemInput {
  createTime: DateTime
  order: Int!
  updateTime: DateTime
  workbookId: Int!
}

input WorkbookProblemCreateManyProblemInputEnvelope {
  data: [WorkbookProblemCreateManyProblemInput!]!
  skipDuplicates: Boolean
}

input WorkbookProblemCreateManyWorkbookInput {
  createTime: DateTime
  order: Int!
  problemId: Int!
  updateTime: DateTime
}

input WorkbookProblemCreateManyWorkbookInputEnvelope {
  data: [WorkbookProblemCreateManyWorkbookInput!]!
  skipDuplicates: Boolean
}

input WorkbookProblemCreateNestedManyWithoutProblemInput {
  connect: [WorkbookProblemWhereUniqueInput!]
  connectOrCreate: [WorkbookProblemCreateOrConnectWithoutProblemInput!]
  create: [WorkbookProblemCreateWithoutProblemInput!]
  createMany: WorkbookProblemCreateManyProblemInputEnvelope
}

input WorkbookProblemCreateNestedManyWithoutWorkbookInput {
  connect: [WorkbookProblemWhereUniqueInput!]
  connectOrCreate: [WorkbookProblemCreateOrConnectWithoutWorkbookInput!]
  create: [WorkbookProblemCreateWithoutWorkbookInput!]
  createMany: WorkbookProblemCreateManyWorkbookInputEnvelope
}

input WorkbookProblemCreateOrConnectWithoutProblemInput {
  create: WorkbookProblemCreateWithoutProblemInput!
  where: WorkbookProblemWhereUniqueInput!
}

input WorkbookProblemCreateOrConnectWithoutWorkbookInput {
  create: WorkbookProblemCreateWithoutWorkbookInput!
  where: WorkbookProblemWhereUniqueInput!
}

input WorkbookProblemCreateWithoutProblemInput {
  createTime: DateTime
  order: Int!
  updateTime: DateTime
  workbook: WorkbookCreateNestedOneWithoutWorkbookProblemInput!
}

input WorkbookProblemCreateWithoutWorkbookInput {
  createTime: DateTime
  order: Int!
  problem: ProblemCreateNestedOneWithoutWorkbookProblemInput!
  updateTime: DateTime
}

input WorkbookProblemListRelationFilter {
  every: WorkbookProblemWhereInput
  none: WorkbookProblemWhereInput
  some: WorkbookProblemWhereInput
}

type WorkbookProblemMaxAggregate {
  createTime: DateTime
  order: Int
  problemId: Int
  updateTime: DateTime
  workbookId: Int
}

type WorkbookProblemMinAggregate {
  createTime: DateTime
  order: Int
  problemId: Int
  updateTime: DateTime
  workbookId: Int
}

input WorkbookProblemScalarWhereInput {
  AND: [WorkbookProblemScalarWhereInput!]
  NOT: [WorkbookProblemScalarWhereInput!]
  OR: [WorkbookProblemScalarWhereInput!]
  createTime: DateTimeFilter
  order: IntFilter
  problemId: IntFilter
  updateTime: DateTimeFilter
  workbookId: IntFilter
}

type WorkbookProblemSumAggregate {
  order: Int
  problemId: Int
  workbookId: Int
}

input WorkbookProblemUpdateManyMutationInput {
  createTime: DateTime
  order: Int
  updateTime: DateTime
}

input WorkbookProblemUpdateManyWithWhereWithoutProblemInput {
  data: WorkbookProblemUpdateManyMutationInput!
  where: WorkbookProblemScalarWhereInput!
}

input WorkbookProblemUpdateManyWithWhereWithoutWorkbookInput {
  data: WorkbookProblemUpdateManyMutationInput!
  where: WorkbookProblemScalarWhereInput!
}

input WorkbookProblemUpdateManyWithoutProblemNestedInput {
  connect: [WorkbookProblemWhereUniqueInput!]
  connectOrCreate: [WorkbookProblemCreateOrConnectWithoutProblemInput!]
  create: [WorkbookProblemCreateWithoutProblemInput!]
  createMany: WorkbookProblemCreateManyProblemInputEnvelope
  delete: [WorkbookProblemWhereUniqueInput!]
  deleteMany: [WorkbookProblemScalarWhereInput!]
  disconnect: [WorkbookProblemWhereUniqueInput!]
  set: [WorkbookProblemWhereUniqueInput!]
  update: [WorkbookProblemUpdateWithWhereUniqueWithoutProblemInput!]
  updateMany: [WorkbookProblemUpdateManyWithWhereWithoutProblemInput!]
  upsert: [WorkbookProblemUpsertWithWhereUniqueWithoutProblemInput!]
}

input WorkbookProblemUpdateManyWithoutWorkbookNestedInput {
  connect: [WorkbookProblemWhereUniqueInput!]
  connectOrCreate: [WorkbookProblemCreateOrConnectWithoutWorkbookInput!]
  create: [WorkbookProblemCreateWithoutWorkbookInput!]
  createMany: WorkbookProblemCreateManyWorkbookInputEnvelope
  delete: [WorkbookProblemWhereUniqueInput!]
  deleteMany: [WorkbookProblemScalarWhereInput!]
  disconnect: [WorkbookProblemWhereUniqueInput!]
  set: [WorkbookProblemWhereUniqueInput!]
  update: [WorkbookProblemUpdateWithWhereUniqueWithoutWorkbookInput!]
  updateMany: [WorkbookProblemUpdateManyWithWhereWithoutWorkbookInput!]
  upsert: [WorkbookProblemUpsertWithWhereUniqueWithoutWorkbookInput!]
}

input WorkbookProblemUpdateWithWhereUniqueWithoutProblemInput {
  data: WorkbookProblemUpdateWithoutProblemInput!
  where: WorkbookProblemWhereUniqueInput!
}

input WorkbookProblemUpdateWithWhereUniqueWithoutWorkbookInput {
  data: WorkbookProblemUpdateWithoutWorkbookInput!
  where: WorkbookProblemWhereUniqueInput!
}

input WorkbookProblemUpdateWithoutProblemInput {
  createTime: DateTime
  order: Int
  updateTime: DateTime
  workbook: WorkbookUpdateOneRequiredWithoutWorkbookProblemNestedInput
}

input WorkbookProblemUpdateWithoutWorkbookInput {
  createTime: DateTime
  order: Int
  problem: ProblemUpdateOneRequiredWithoutWorkbookProblemNestedInput
  updateTime: DateTime
}

input WorkbookProblemUpsertWithWhereUniqueWithoutProblemInput {
  create: WorkbookProblemCreateWithoutProblemInput!
  update: WorkbookProblemUpdateWithoutProblemInput!
  where: WorkbookProblemWhereUniqueInput!
}

input WorkbookProblemUpsertWithWhereUniqueWithoutWorkbookInput {
  create: WorkbookProblemCreateWithoutWorkbookInput!
  update: WorkbookProblemUpdateWithoutWorkbookInput!
  where: WorkbookProblemWhereUniqueInput!
}

input WorkbookProblemWhereInput {
  AND: [WorkbookProblemWhereInput!]
  NOT: [WorkbookProblemWhereInput!]
  OR: [WorkbookProblemWhereInput!]
  createTime: DateTimeFilter
  order: IntFilter
  problem: ProblemRelationFilter
  problemId: IntFilter
  updateTime: DateTimeFilter
  workbook: WorkbookRelationFilter
  workbookId: IntFilter
}

input WorkbookProblemWhereUniqueInput {
  AND: [WorkbookProblemWhereInput!]
  NOT: [WorkbookProblemWhereInput!]
  OR: [WorkbookProblemWhereInput!]
  createTime: DateTimeFilter
  order: IntFilter
  problem: ProblemRelationFilter
  problemId: IntFilter
  updateTime: DateTimeFilter
  workbook: WorkbookRelationFilter
  workbookId: IntFilter
  workbookId_problemId: WorkbookProblemWorkbookIdProblemIdCompoundUniqueInput
}

input WorkbookProblemWorkbookIdProblemIdCompoundUniqueInput {
  problemId: Int!
  workbookId: Int!
}

input WorkbookRelationFilter {
  is: WorkbookWhereInput
  isNot: WorkbookWhereInput
}

input WorkbookScalarWhereInput {
  AND: [WorkbookScalarWhereInput!]
  NOT: [WorkbookScalarWhereInput!]
  OR: [WorkbookScalarWhereInput!]
  createTime: DateTimeFilter
  createdById: IntNullableFilter
  description: StringFilter
  groupId: IntFilter
  id: IntFilter
  isVisible: BoolFilter
  title: StringFilter
  updateTime: DateTimeFilter
}

type WorkbookSumAggregate {
  createdById: Int
  groupId: Int
  id: Int
}

input WorkbookUpdateManyMutationInput {
  createTime: DateTime
  description: String
  isVisible: Boolean
  title: String
  updateTime: DateTime
}

input WorkbookUpdateManyWithWhereWithoutCreatedByInput {
  data: WorkbookUpdateManyMutationInput!
  where: WorkbookScalarWhereInput!
}

input WorkbookUpdateManyWithWhereWithoutGroupInput {
  data: WorkbookUpdateManyMutationInput!
  where: WorkbookScalarWhereInput!
}

input WorkbookUpdateManyWithoutCreatedByNestedInput {
  connect: [WorkbookWhereUniqueInput!]
  connectOrCreate: [WorkbookCreateOrConnectWithoutCreatedByInput!]
  create: [WorkbookCreateWithoutCreatedByInput!]
  createMany: WorkbookCreateManyCreatedByInputEnvelope
  delete: [WorkbookWhereUniqueInput!]
  deleteMany: [WorkbookScalarWhereInput!]
  disconnect: [WorkbookWhereUniqueInput!]
  set: [WorkbookWhereUniqueInput!]
  update: [WorkbookUpdateWithWhereUniqueWithoutCreatedByInput!]
  updateMany: [WorkbookUpdateManyWithWhereWithoutCreatedByInput!]
  upsert: [WorkbookUpsertWithWhereUniqueWithoutCreatedByInput!]
}

input WorkbookUpdateManyWithoutGroupNestedInput {
  connect: [WorkbookWhereUniqueInput!]
  connectOrCreate: [WorkbookCreateOrConnectWithoutGroupInput!]
  create: [WorkbookCreateWithoutGroupInput!]
  createMany: WorkbookCreateManyGroupInputEnvelope
  delete: [WorkbookWhereUniqueInput!]
  deleteMany: [WorkbookScalarWhereInput!]
  disconnect: [WorkbookWhereUniqueInput!]
  set: [WorkbookWhereUniqueInput!]
  update: [WorkbookUpdateWithWhereUniqueWithoutGroupInput!]
  updateMany: [WorkbookUpdateManyWithWhereWithoutGroupInput!]
  upsert: [WorkbookUpsertWithWhereUniqueWithoutGroupInput!]
}

input WorkbookUpdateOneRequiredWithoutWorkbookProblemNestedInput {
  connect: WorkbookWhereUniqueInput
  connectOrCreate: WorkbookCreateOrConnectWithoutWorkbookProblemInput
  create: WorkbookCreateWithoutWorkbookProblemInput
  update: WorkbookUpdateToOneWithWhereWithoutWorkbookProblemInput
  upsert: WorkbookUpsertWithoutWorkbookProblemInput
}

input WorkbookUpdateOneWithoutSubmissionNestedInput {
  connect: WorkbookWhereUniqueInput
  connectOrCreate: WorkbookCreateOrConnectWithoutSubmissionInput
  create: WorkbookCreateWithoutSubmissionInput
  delete: WorkbookWhereInput
  disconnect: WorkbookWhereInput
  update: WorkbookUpdateToOneWithWhereWithoutSubmissionInput
  upsert: WorkbookUpsertWithoutSubmissionInput
}

input WorkbookUpdateToOneWithWhereWithoutSubmissionInput {
  data: WorkbookUpdateWithoutSubmissionInput!
  where: WorkbookWhereInput
}

input WorkbookUpdateToOneWithWhereWithoutWorkbookProblemInput {
  data: WorkbookUpdateWithoutWorkbookProblemInput!
  where: WorkbookWhereInput
}

input WorkbookUpdateWithWhereUniqueWithoutCreatedByInput {
  data: WorkbookUpdateWithoutCreatedByInput!
  where: WorkbookWhereUniqueInput!
}

input WorkbookUpdateWithWhereUniqueWithoutGroupInput {
  data: WorkbookUpdateWithoutGroupInput!
  where: WorkbookWhereUniqueInput!
}

input WorkbookUpdateWithoutCreatedByInput {
  createTime: DateTime
  description: String
  group: GroupUpdateOneRequiredWithoutWorkbookNestedInput
  isVisible: Boolean
  submission: SubmissionUpdateManyWithoutWorkbookNestedInput
  title: String
  updateTime: DateTime
  workbookProblem: WorkbookProblemUpdateManyWithoutWorkbookNestedInput
}

input WorkbookUpdateWithoutGroupInput {
  createTime: DateTime
  createdBy: UserUpdateOneWithoutWorkbookNestedInput
  description: String
  isVisible: Boolean
  submission: SubmissionUpdateManyWithoutWorkbookNestedInput
  title: String
  updateTime: DateTime
  workbookProblem: WorkbookProblemUpdateManyWithoutWorkbookNestedInput
}

input WorkbookUpdateWithoutSubmissionInput {
  createTime: DateTime
  createdBy: UserUpdateOneWithoutWorkbookNestedInput
  description: String
  group: GroupUpdateOneRequiredWithoutWorkbookNestedInput
  isVisible: Boolean
  title: String
  updateTime: DateTime
  workbookProblem: WorkbookProblemUpdateManyWithoutWorkbookNestedInput
}

input WorkbookUpdateWithoutWorkbookProblemInput {
  createTime: DateTime
  createdBy: UserUpdateOneWithoutWorkbookNestedInput
  description: String
  group: GroupUpdateOneRequiredWithoutWorkbookNestedInput
  isVisible: Boolean
  submission: SubmissionUpdateManyWithoutWorkbookNestedInput
  title: String
  updateTime: DateTime
}

input WorkbookUpsertWithWhereUniqueWithoutCreatedByInput {
  create: WorkbookCreateWithoutCreatedByInput!
  update: WorkbookUpdateWithoutCreatedByInput!
  where: WorkbookWhereUniqueInput!
}

input WorkbookUpsertWithWhereUniqueWithoutGroupInput {
  create: WorkbookCreateWithoutGroupInput!
  update: WorkbookUpdateWithoutGroupInput!
  where: WorkbookWhereUniqueInput!
}

input WorkbookUpsertWithoutSubmissionInput {
  create: WorkbookCreateWithoutSubmissionInput!
  update: WorkbookUpdateWithoutSubmissionInput!
  where: WorkbookWhereInput
}

input WorkbookUpsertWithoutWorkbookProblemInput {
  create: WorkbookCreateWithoutWorkbookProblemInput!
  update: WorkbookUpdateWithoutWorkbookProblemInput!
  where: WorkbookWhereInput
}

input WorkbookWhereInput {
  AND: [WorkbookWhereInput!]
  NOT: [WorkbookWhereInput!]
  OR: [WorkbookWhereInput!]
  createTime: DateTimeFilter
  createdBy: UserNullableRelationFilter
  createdById: IntNullableFilter
  description: StringFilter
  group: GroupRelationFilter
  groupId: IntFilter
  id: IntFilter
  isVisible: BoolFilter
  submission: SubmissionListRelationFilter
  title: StringFilter
  updateTime: DateTimeFilter
  workbookProblem: WorkbookProblemListRelationFilter
}

input WorkbookWhereUniqueInput {
  AND: [WorkbookWhereInput!]
  NOT: [WorkbookWhereInput!]
  OR: [WorkbookWhereInput!]
  createTime: DateTimeFilter
  createdBy: UserNullableRelationFilter
  createdById: IntNullableFilter
  description: StringFilter
  group: GroupRelationFilter
  groupId: IntFilter
  id: Int
  isVisible: BoolFilter
  submission: SubmissionListRelationFilter
  title: StringFilter
  updateTime: DateTimeFilter
  workbookProblem: WorkbookProblemListRelationFilter
}